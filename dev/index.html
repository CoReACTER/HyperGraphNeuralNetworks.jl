<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · HyperGraphNeuralNetworks.jl</title><meta name="title" content="Home · HyperGraphNeuralNetworks.jl"/><meta property="og:title" content="Home · HyperGraphNeuralNetworks.jl"/><meta property="twitter:title" content="Home · HyperGraphNeuralNetworks.jl"/><meta name="description" content="Documentation for HyperGraphNeuralNetworks.jl."/><meta property="og:description" content="Documentation for HyperGraphNeuralNetworks.jl."/><meta property="twitter:description" content="Documentation for HyperGraphNeuralNetworks.jl."/><meta property="og:url" content="https://CoReACTER.org/HyperGraphNeuralNetworks.jl/"/><meta property="twitter:url" content="https://CoReACTER.org/HyperGraphNeuralNetworks.jl/"/><link rel="canonical" href="https://CoReACTER.org/HyperGraphNeuralNetworks.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>HyperGraphNeuralNetworks.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="HyperGraphNeuralNetworks"><a class="docs-heading-anchor" href="#HyperGraphNeuralNetworks">HyperGraphNeuralNetworks</a><a id="HyperGraphNeuralNetworks-1"></a><a class="docs-heading-anchor-permalink" href="#HyperGraphNeuralNetworks" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl">HyperGraphNeuralNetworks</a>.</p><ul><li><a href="#HyperGraphNeuralNetworks.AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.AbstractHGNNDiHypergraph</code></a></li><li><a href="#HyperGraphNeuralNetworks.AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.AbstractHGNNHypergraph</code></a></li><li><a href="#HyperGraphNeuralNetworks.AbstractNegativeSamplingStrategy"><code>HyperGraphNeuralNetworks.AbstractNegativeSamplingStrategy</code></a></li><li><a href="#HyperGraphNeuralNetworks.HGNNHypergraph"><code>HyperGraphNeuralNetworks.HGNNHypergraph</code></a></li><li><a href="#Base.copy-Tuple{HGNNHypergraph}"><code>Base.copy</code></a></li><li><a href="#Base.copy-Tuple{HGNNDiHypergraph}"><code>Base.copy</code></a></li><li><a href="#Graphs.LinAlg.incidence_matrix-Tuple{H} where H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph"><code>Graphs.LinAlg.incidence_matrix</code></a></li><li><a href="#Graphs.LinAlg.incidence_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph"><code>Graphs.LinAlg.incidence_matrix</code></a></li><li><a href="#Graphs.all_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.all_neighbors</code></a></li><li><a href="#Graphs.all_neighbors-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.all_neighbors</code></a></li><li><a href="#Graphs.all_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNHypergraph"><code>Graphs.all_neighbors</code></a></li><li><a href="#Graphs.all_neighbors-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>Graphs.all_neighbors</code></a></li><li><a href="#Graphs.degree-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.degree</code></a></li><li><a href="#Graphs.degree-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>Graphs.degree</code></a></li><li><a href="#Graphs.has_self_loops-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>Graphs.has_self_loops</code></a></li><li><a href="#Graphs.indegree-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.indegree</code></a></li><li><a href="#Graphs.inneighbors-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.inneighbors</code></a></li><li><a href="#Graphs.inneighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.inneighbors</code></a></li><li><a href="#Graphs.outdegree-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.outdegree</code></a></li><li><a href="#Graphs.outneighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.outneighbors</code></a></li><li><a href="#Graphs.outneighbors-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.outneighbors</code></a></li><li><a href="#HyperGraphNeuralNetworks.add_hyperedge-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_hyperedge</code></a></li><li><a href="#HyperGraphNeuralNetworks.add_hyperedge-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_hyperedge</code></a></li><li><a href="#HyperGraphNeuralNetworks.add_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_hyperedges</code></a></li><li><a href="#HyperGraphNeuralNetworks.add_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_hyperedges</code></a></li><li><a href="#HyperGraphNeuralNetworks.add_selfloops-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_selfloops</code></a></li><li><a href="#HyperGraphNeuralNetworks.add_selfloops-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_selfloops</code></a></li><li><a href="#HyperGraphNeuralNetworks.add_vertex-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_vertex</code></a></li><li><a href="#HyperGraphNeuralNetworks.add_vertex-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_vertex</code></a></li><li><a href="#HyperGraphNeuralNetworks.add_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_vertices</code></a></li><li><a href="#HyperGraphNeuralNetworks.add_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_vertices</code></a></li><li><a href="#HyperGraphNeuralNetworks.check_num_hyperedges-Union{Tuple{H}, Tuple{H, AbstractArray}} where H&lt;:AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.check_num_hyperedges</code></a></li><li><a href="#HyperGraphNeuralNetworks.check_num_hyperedges-Union{Tuple{H}, Tuple{H, AbstractArray}} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.check_num_hyperedges</code></a></li><li><a href="#HyperGraphNeuralNetworks.check_num_vertices-Union{Tuple{H}, Tuple{H, AbstractArray}} where H&lt;:AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.check_num_vertices</code></a></li><li><a href="#HyperGraphNeuralNetworks.check_num_vertices-Union{Tuple{H}, Tuple{H, AbstractArray}} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.check_num_vertices</code></a></li><li><a href="#HyperGraphNeuralNetworks.clique_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.clique_negative_sample</code></a></li><li><a href="#HyperGraphNeuralNetworks.combine_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, HGNNDiHypergraph{T, D}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.combine_hypergraphs</code></a></li><li><a href="#HyperGraphNeuralNetworks.combine_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, HGNNHypergraph{T, D}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.combine_hypergraphs</code></a></li><li><a href="#HyperGraphNeuralNetworks.complex_incidence_matrix-Tuple{H} where H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph"><code>HyperGraphNeuralNetworks.complex_incidence_matrix</code></a></li><li><a href="#HyperGraphNeuralNetworks.erdos_renyi_hypergraph-Union{Tuple{H}, Tuple{Int64, Int64, Type{H}}} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.erdos_renyi_hypergraph</code></a></li><li><a href="#HyperGraphNeuralNetworks.get_hyperedge_weight-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.get_hyperedge_weight</code></a></li><li><a href="#HyperGraphNeuralNetworks.get_hyperedge_weight-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.get_hyperedge_weight</code></a></li><li><a href="#HyperGraphNeuralNetworks.get_hyperedge_weights-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.get_hyperedge_weights</code></a></li><li><a href="#HyperGraphNeuralNetworks.get_hyperedge_weights-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.get_hyperedge_weights</code></a></li><li><a href="#HyperGraphNeuralNetworks.get_hypergraph-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.get_hypergraph</code></a></li><li><a href="#HyperGraphNeuralNetworks.get_hypergraph-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.get_hypergraph</code></a></li><li><a href="#HyperGraphNeuralNetworks.has_multi_hyperedges-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.has_multi_hyperedges</code></a></li><li><a href="#HyperGraphNeuralNetworks.hyperedge_degree_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_degree_matrix</code></a></li><li><a href="#HyperGraphNeuralNetworks.hyperedge_index-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_index</code></a></li><li><a href="#HyperGraphNeuralNetworks.hyperedge_index-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_index</code></a></li><li><a href="#HyperGraphNeuralNetworks.hyperedge_neighbors-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_neighbors</code></a></li><li><a href="#HyperGraphNeuralNetworks.hyperedge_neighbors-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_neighbors</code></a></li><li><a href="#HyperGraphNeuralNetworks.hyperedge_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_neighbors</code></a></li><li><a href="#HyperGraphNeuralNetworks.hyperedge_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_neighbors</code></a></li><li><a href="#HyperGraphNeuralNetworks.hyperedge_weight_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_weight_matrix</code></a></li><li><a href="#HyperGraphNeuralNetworks.hyperedge_weight_matrix-Tuple{H} where H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_weight_matrix</code></a></li><li><a href="#HyperGraphNeuralNetworks.hypergraph_ids-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.hypergraph_ids</code></a></li><li><a href="#HyperGraphNeuralNetworks.motif_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.motif_negative_sample</code></a></li><li><a href="#HyperGraphNeuralNetworks.motif_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.motif_negative_sample</code></a></li><li><a href="#HyperGraphNeuralNetworks.negative_sample_hyperedge-Union{Tuple{S}, Tuple{H}, Tuple{H, Int64, Random.AbstractRNG, S}} where {H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph, S&lt;:AbstractNegativeSamplingStrategy}"><code>HyperGraphNeuralNetworks.negative_sample_hyperedge</code></a></li><li><a href="#HyperGraphNeuralNetworks.negative_sample_hyperedge-Union{Tuple{S}, Tuple{H}, Tuple{H, Int64, Random.AbstractRNG, S}} where {H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph, S&lt;:AbstractNegativeSamplingStrategy}"><code>HyperGraphNeuralNetworks.negative_sample_hyperedge</code></a></li><li><a href="#HyperGraphNeuralNetworks.normalized_laplacian_matrix-Tuple{H} where H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph"><code>HyperGraphNeuralNetworks.normalized_laplacian_matrix</code></a></li><li><a href="#HyperGraphNeuralNetworks.normalized_laplacian_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph"><code>HyperGraphNeuralNetworks.normalized_laplacian_matrix</code></a></li><li><a href="#HyperGraphNeuralNetworks.print_all_features-Tuple{IO, Any, Any, Any}"><code>HyperGraphNeuralNetworks.print_all_features</code></a></li><li><a href="#HyperGraphNeuralNetworks.random_dregular_hypergraph-Union{Tuple{H}, Tuple{Int64, Int64, Int64, Type{H}}} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.random_dregular_hypergraph</code></a></li><li><a href="#HyperGraphNeuralNetworks.random_kuniform_hypergraph-Union{Tuple{H}, Tuple{Int64, Int64, Int64, Type{H}}} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.random_kuniform_hypergraph</code></a></li><li><a href="#HyperGraphNeuralNetworks.random_preferential_hypergraph-Union{Tuple{HO}, Tuple{HI}, Tuple{Int64, Real, Type{HO}}} where {HI&lt;:SimpleHypergraphs.AbstractSimpleHypergraph, HO&lt;:AbstractHGNNHypergraph}"><code>HyperGraphNeuralNetworks.random_preferential_hypergraph</code></a></li><li><a href="#HyperGraphNeuralNetworks.random_split_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{&lt;:Real}, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.random_split_hyperedges</code></a></li><li><a href="#HyperGraphNeuralNetworks.random_split_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{&lt;:Real}, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.random_split_hypergraphs</code></a></li><li><a href="#HyperGraphNeuralNetworks.random_split_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{&lt;:Real}, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.random_split_vertices</code></a></li><li><a href="#HyperGraphNeuralNetworks.remove_hyperedge-Tuple{HGNNHypergraph, Int64}"><code>HyperGraphNeuralNetworks.remove_hyperedge</code></a></li><li><a href="#HyperGraphNeuralNetworks.remove_hyperedge-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.remove_hyperedge</code></a></li><li><a href="#HyperGraphNeuralNetworks.remove_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{Int64}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.remove_hyperedges</code></a></li><li><a href="#HyperGraphNeuralNetworks.remove_hyperedges-Tuple{HGNNHypergraph, AbstractVector{Int64}}"><code>HyperGraphNeuralNetworks.remove_hyperedges</code></a></li><li><a href="#HyperGraphNeuralNetworks.remove_multihyperedges-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.remove_multihyperedges</code></a></li><li><a href="#HyperGraphNeuralNetworks.remove_multihyperedges-Tuple{HGNNHypergraph}"><code>HyperGraphNeuralNetworks.remove_multihyperedges</code></a></li><li><a href="#HyperGraphNeuralNetworks.remove_selfloops-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.remove_selfloops</code></a></li><li><a href="#HyperGraphNeuralNetworks.remove_selfloops-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.remove_selfloops</code></a></li><li><a href="#HyperGraphNeuralNetworks.remove_vertex-Tuple{HGNNHypergraph, Int64}"><code>HyperGraphNeuralNetworks.remove_vertex</code></a></li><li><a href="#HyperGraphNeuralNetworks.remove_vertex-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.remove_vertex</code></a></li><li><a href="#HyperGraphNeuralNetworks.remove_vertices-Tuple{HGNNHypergraph, AbstractVector{Int64}}"><code>HyperGraphNeuralNetworks.remove_vertices</code></a></li><li><a href="#HyperGraphNeuralNetworks.remove_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{Int64}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.remove_vertices</code></a></li><li><a href="#HyperGraphNeuralNetworks.sized_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.sized_negative_sample</code></a></li><li><a href="#HyperGraphNeuralNetworks.sized_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.sized_negative_sample</code></a></li><li><a href="#HyperGraphNeuralNetworks.split_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.split_hyperedges</code></a></li><li><a href="#HyperGraphNeuralNetworks.split_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.split_hyperedges</code></a></li><li><a href="#HyperGraphNeuralNetworks.split_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.split_hypergraphs</code></a></li><li><a href="#HyperGraphNeuralNetworks.split_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.split_hypergraphs</code></a></li><li><a href="#HyperGraphNeuralNetworks.split_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.split_vertices</code></a></li><li><a href="#HyperGraphNeuralNetworks.split_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.split_vertices</code></a></li><li><a href="#HyperGraphNeuralNetworks.uniform_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.uniform_negative_sample</code></a></li><li><a href="#HyperGraphNeuralNetworks.uniform_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.uniform_negative_sample</code></a></li><li><a href="#HyperGraphNeuralNetworks.vertex_degree_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph"><code>HyperGraphNeuralNetworks.vertex_degree_matrix</code></a></li><li><a href="#HyperGraphNeuralNetworks.vertex_weight_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph"><code>HyperGraphNeuralNetworks.vertex_weight_matrix</code></a></li><li><a href="#HyperGraphNeuralNetworks.vertex_weight_matrix-Tuple{H} where H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph"><code>HyperGraphNeuralNetworks.vertex_weight_matrix</code></a></li><li><a href="#SimpleDirectedHypergraphs.to_undirected-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>SimpleDirectedHypergraphs.to_undirected</code></a></li><li><a href="#SimpleHypergraphs.add_hyperedge!-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>SimpleHypergraphs.add_hyperedge!</code></a></li><li><a href="#SimpleHypergraphs.add_hyperedge!-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>SimpleHypergraphs.add_hyperedge!</code></a></li><li><a href="#SimpleHypergraphs.add_vertex!-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>SimpleHypergraphs.add_vertex!</code></a></li><li><a href="#SimpleHypergraphs.add_vertex!-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>SimpleHypergraphs.add_vertex!</code></a></li><li><a href="#SimpleHypergraphs.remove_hyperedge!-Tuple{HGNNHypergraph, Int64}"><code>SimpleHypergraphs.remove_hyperedge!</code></a></li><li><a href="#SimpleHypergraphs.remove_hyperedge!-Tuple{HGNNDiHypergraph, Int64}"><code>SimpleHypergraphs.remove_hyperedge!</code></a></li><li><a href="#SimpleHypergraphs.remove_vertex!-Tuple{HGNNDiHypergraph, Int64}"><code>SimpleHypergraphs.remove_vertex!</code></a></li><li><a href="#SimpleHypergraphs.remove_vertex!-Tuple{HGNNHypergraph, Int64}"><code>SimpleHypergraphs.remove_vertex!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.AbstractHGNNDiHypergraph" href="#HyperGraphNeuralNetworks.AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.AbstractHGNNDiHypergraph</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractHGNNDiHypergraph{T} &lt;: AbstractDirectedHypergraph{T}</code></pre><p>An abstract directed hypergraph type for use in machine learning</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/abstracttypes.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.AbstractHGNNHypergraph" href="#HyperGraphNeuralNetworks.AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.AbstractHGNNHypergraph</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractHGNNHypergraph{T} &lt;: AbstractSimpleHypergraph{T}</code></pre><p>An abstract undirected hypergraph type for use in machine learning</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/abstracttypes.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.AbstractNegativeSamplingStrategy" href="#HyperGraphNeuralNetworks.AbstractNegativeSamplingStrategy"><code>HyperGraphNeuralNetworks.AbstractNegativeSamplingStrategy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractNegativeSamplingStrategy
struct UniformSample &lt;: AbstractNegativeSamplingStrategy
struct SizedSample &lt;: AbstractNegativeSamplingStrategy
struct MotifSample &lt;: AbstractNegativeSamplingStrategy
struct CliqueSample &lt;: AbstractNegativeSamplingStrategy

Types for negative sampling of hyperedges in hypergraphs (see `negative_sample_hyperedge`).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L775-L783">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.HGNNHypergraph" href="#HyperGraphNeuralNetworks.HGNNHypergraph"><code>HyperGraphNeuralNetworks.HGNNHypergraph</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>HGNNHypergraph{T&lt;:Real, D&lt;:AbstractDict{Int,T}} &lt;: AbstractHGNNHypergraph{Union{T, Nothing}}</p><p>An undirected hypergraph type for use in hypergraph neural networks</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">HGNNHypergraph{T,D}(
    h::AbstractSimpleHypergraph;
    hypergraph_ids::Union{Nothing, AbstractVector{&lt;:Integer}} = nothing,
    vdata = nothing,
    hedata = nothing,
    hgdata = nothing
) where {T&lt;:Real, D&lt;:AbstractDict{Int, T}}

HGNNHypergraph{T}(
    h::AbstractSimpleHypergraph;
    hypergraph_ids::Union{Nothing, AbstractVector{&lt;:Integer}} = nothing,
    vdata::Union{DataStore, Nothing} = nothing,
    hedata::Union{DataStore, Nothing} = nothing,
    hgdata::Union{DataStore, Nothing} = nothing
) where {T&lt;:Real}

HGNNHypergraph(
    h::AbstractSimpleHypergraph;
    hypergraph_ids::Union{Nothing, AbstractVector{&lt;:Integer}} = nothing,
    vdata = nothing,
    hedata = nothing,
    hgdata = nothing
)

Construct an `HGNNHypergraph` from a previously constructed hypergraph. Optionally, the user can specify
what hypergraph each vertex belongs to (if multiple distinct hypergraphs are included), as well as vertex,
hyperedge, and hypergraph features.

HGNNHypergraph{T,D}(
    incidence::Matrix{Union{T, Nothing}};
    hypergraph_ids::Union{Nothing, AbstractVector{&lt;:Integer}} = nothing,
    vdata = nothing,
    hedata = nothing,
    hgdata = nothing
) where {T&lt;:Real, D&lt;:AbstractDict{Int, T}}

HGNNHypergraph{T}(
    incidence::Matrix{Union{T, Nothing}};
    hypergraph_ids::Union{Nothing, AbstractVector{&lt;:Integer}} = nothing,
    vdata = nothing,
    hedata = nothing,
    hgdata = nothing
) where {T&lt;:Real}

HGNNHypergraph(
    incidence::Matrix{Union{T, Nothing}};
    hypergraph_ids::Union{Nothing, AbstractVector{&lt;:Integer}} = nothing,
    vdata = nothing,
    hedata = nothing,
    hgdata = nothing
) where {T&lt;:Real}

Construct an `HGNNHypergraph` from an incidence matrix. The incidence matrix is an `M`x`N` matrix, where `M` is the
number of vertices and `N` is the number of hyperedges.

function HGNNHypergraph(num_nodes::T; vdata=nothing, kws...) where {T&lt;:Integer}

Construct an `HGNNHypergraph` with no hyperedges and `num_nodes` vertices.

function HGNNHypergraph(; num_nodes=nothing, vdata=nothing, kws...)

Construct an `HGNNHypergraph` with minimal (perhaps no) information.</code></pre><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">* `T` : type of weight values stored in the hypergraph&#39;s incidence matrix
* `D` : dictionary type for storing values; the default is `Dict{Int, T}`
* `hypergraph_ids` : Nothing (implying that all vertices belong to the same hypergraph) or a vector of ID integers
* `vdata` : an optional DataStore (from GNNGraphs.jl) containing vertex-level features. Each entry in `vdata`
    should have `M` entries/observations, where `M` is the number of vertices in the hypergraph
* `hedata` : an optional DataStore containing hyperedge-level features. Each entry in `hedata` should have `N`
    entries/observations, where `N` is the number of hyperedges in the hypergraph
* `hgdata` : an optional DataStore containing hypergraph-level features. Each entry in `hgdata` should have `G`
    entries/observations, where `G` is the number of hypergraphs in the HGNNHypergraph (note: the maximum index
    in `hypergraph_ids` should be `G`)
* `incidence` : a matrix representation; rows are vertices and columns are hyperedges
* `num_nodes` : the number of vertices in the hypergraph (i.e., `M`)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L4-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy-Tuple{HGNNDiHypergraph}" href="#Base.copy-Tuple{HGNNDiHypergraph}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy(hg::HGNNDiHypergraph; deep=false)</code></pre><p>Create a copy of <code>hg</code>. If <code>deep</code> is <code>true</code>, then copy will be a deep copy (equivalent to <code>deepcopy(hg)</code>), otherwise it will be a shallow copy with the same underlying hypergraph data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L1765-L1770">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy-Tuple{HGNNHypergraph}" href="#Base.copy-Tuple{HGNNHypergraph}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy(hg::HGNNHypergraph; deep=false)

Create a copy of `hg`. If `deep` is `true`, then copy will be a deep copy (equivalent to `deepcopy(hg)`),
therwise it will be a shallow copy with the same underlying hypergraph data.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L699-L704">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.LinAlg.incidence_matrix-Tuple{H} where H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph" href="#Graphs.LinAlg.incidence_matrix-Tuple{H} where H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph"><code>Graphs.LinAlg.incidence_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">incidence_matrix(hg::H) where {H &lt;: AbstractDirectedHypergraph}

Convert the matrix representation of an undirected hypergraph `hg` into two incidence matrices, `Mt` (the tail
incidence matrix) and `Mh` (the head incidence matrix). The (i,j)-th element of `Mt` is 1 if vertex `i` is in the
tail of hyperedge `j` and 0 otherwise. Likewise, `Mh`[i, j] is 1 if `i` is in the head of `j` and 0 otherwise</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L575-L581">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.LinAlg.incidence_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph" href="#Graphs.LinAlg.incidence_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph"><code>Graphs.LinAlg.incidence_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">incidence_matrix(hg::H) where {H &lt;: AbstractSimpleHypergraph}

Convert the matrix representation of an undirected hypergraph `hg` to an incidence matrix. The (i,j)-th element of
the incidence matrix `M` is 1 if vertex `i` is in hyperedge `j` and 0 otherwise.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L561-L566">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.all_neighbors-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph" href="#Graphs.all_neighbors-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.all_neighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">all_neighbors(hg::H; same_side::Bool=false) where {H &lt;: AbstractHGNNDiHypergraph}

Returns all neighbors for all vertices in a directed hypergraph. The set of all neighbors for a vertex is the union
of the set of all incoming neighbors and outgoing neighbors. Note that the definition of `incoming` and `outgoing`
neighbor depends on if `same_side` is true or false; see below.

Args:
    hg::H where {H &lt;: AbstractHGNNDiHypergraph} : Hypergraph
    same_side::Bool : If true, return the neighbors within the same side of a hyperedge; i.e., if vertex
    `i` and vertex `j` are both in the tail of hyperedge `e`, they are neighbors. If false, instead return
    the neighbors on the opposite side of the hyperedge; i.e., if vertex `i` is in the tail of `e` and vertex
    `j` is in the head of `e`, then `i` and `j` are neighbors. Default is false.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L235-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.all_neighbors-Tuple{H} where H&lt;:AbstractHGNNHypergraph" href="#Graphs.all_neighbors-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>Graphs.all_neighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">all_neighbors(hg::H) where {H &lt;: AbstractHGNNHypergraph}

Collect all neighbors for all vertices in an undirected hypergraph.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.all_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNDiHypergraph" href="#Graphs.all_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.all_neighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">all_neighbors(hg::H, i::Int; same_side::Bool=false) where {H &lt;: AbstractHGNNDiHypergraph}

Returns the neighbors for vertex `i` in a directed hypergraph `hg`. The set of all neighbors for a vertex is the
union of the set of all incoming neighbors and outgoing neighbors. Note that the definition of `incoming` and
`outgoing` neighbor depends on if `same_side` is true or false; see below.

Args:
    hg::H where {H &lt;: AbstractHGNNDiHypergraph} : Hypergraph
    i::Int : Vertex index
    same_side::Bool : If true, return the neighbors within the same side of a hyperedge; i.e., if vertex
    `i` and vertex `j` are both in the tail of hyperedge `e`, they are neighbors. If false, instead return
    the neighbors on the opposite side of the hyperedge; i.e., if vertex `i` is in the tail of `e` and vertex
    `j` is in the head of `e`, then `i` and `j` are neighbors. Default is false.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L259-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.all_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNHypergraph" href="#Graphs.all_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNHypergraph"><code>Graphs.all_neighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">all_neighbors(hg::H, i::Int) where {H &lt;: AbstractHGNNHypergraph}

Returns the neighbors of vertex `i` in undirected hypergraph `hg`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L217-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.degree-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph" href="#Graphs.degree-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.degree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">degree(hg::H) where {H &lt;: AbstractHGNNDiHypergraph}
degree(hg::H, i::Int) where {H &lt;: AbstractHGNNDiHypergraph}
degree(hg::H, inds::AbstractVector{Int}) where {H &lt;: AbstractHGNNDiHypergraph}

Return the degree of all vertices (if no index is provided) or of a specific group of indices
For directed hypergraphs, the total degree is the sum of the incoming degree (see `indegree`) and the
outgoing degree (see `outdegree`).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L157-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.degree-Tuple{H} where H&lt;:AbstractHGNNHypergraph" href="#Graphs.degree-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>Graphs.degree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">degree(hg::H) where {H &lt;: AbstractHGNNHypergraph}
degree(hg::H, i::Int) where {H &lt;: AbstractHGNNHypergraph}
degree(hg::H, inds::AbstractVector{Int}) where {H &lt;: AbstractHGNNHypergraph}

Return the degree of all vertices (if no index is provided) or of a specific group of vertices.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L146-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.has_self_loops-Tuple{H} where H&lt;:AbstractHGNNHypergraph" href="#Graphs.has_self_loops-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>Graphs.has_self_loops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_self_loops(_::H) where {H &lt;: AbstractHGNNHypergraph}
has_self_loops(hg::H) where {H &lt;: AbstractHGNNDiHypergraph}

Does the hypergraph contain self-loops? For an undirected hypergraph, this is defined to always be `false`. For a
directed hypergraph, this function checks the intersection between the tail and the head of each hyperedge in `hg`.
If any intersections are nonempty, then the dihypergraph has a self-loop.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L846-L853">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.indegree-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph" href="#Graphs.indegree-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.indegree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">indegree(hg::H) where {H &lt;: AbstractHGNNDiHypergraph}
indegree(hg::H, i::Int) where {H &lt;: AbstractHGNNDiHypergraph}
indegree(hg::H, inds::AbstractVector{Int}) where {H &lt;: AbstractHGNNDiHypergraph}

Return the incoming degree of all vertices (if no index is provided) or of a specific group of indices for a
directed hypergraph. The incoming degree is the number of directed hyperedges containing a vertex in the head.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L170-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.inneighbors-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph" href="#Graphs.inneighbors-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.inneighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inneighbors(hg::H; same_side::Bool=false) where {H &lt;: AbstractHGNNDiHypergraph}

Return the incoming neighbors for a directed hypergraph `hg`. Note that the definition of `incoming` depends on
if `same_side` is true or false; see below.

Args:
    hg::H where {H &lt;: AbstractHGNNDiHypergraph} : Hypergraph
    same_side::Bool : If true, return the neighbors that share a hyperedge head with each vertex; i.e., if vertex
    `i` and vertex `j` are both in the head of some hyperedge `e`, they are incoming neighbors. If false, instead
    return the neighbors on the opposite side of the hyperedge; i.e., if vertex `i` is in the head of `e` and vertex
    `j` is in the tail of `e`, then `j` is an incoming neighbor to `i`. Default is false.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L284-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.inneighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNDiHypergraph" href="#Graphs.inneighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.inneighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inneighbors(hg::H, i::Int; same_side::Bool=false) where {H &lt;: AbstractHGNNDiHypergraph}

Return the incoming neighbors for a vertex `i` of a directed hypergraph `hg`. Note that the definition of
`incoming` depends on if `same_side` is true or false; see below.

Args:
    hg::H where {H &lt;: AbstractHGNNDiHypergraph} : Hypergraph
    i::Int : Vertex index
    same_side::Bool : If true, return the neighbors that share a hyperedge head with each vertex; i.e., if vertex
    `i` and vertex `j` are both in the head of some hyperedge `e`, they are incoming neighbors. If false, instead
    return the neighbors on the opposite side of the hyperedge; i.e., if vertex `i` is in the head of `e` and vertex
    `j` is in the tail of `e`, then `j` is an incoming neighbor to `i`. Default is false.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L318-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.outdegree-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph" href="#Graphs.outdegree-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.outdegree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">outdegree(hg::H) where {H &lt;: AbstractHGNNDiHypergraph}
outdegree(hg::H, i::Int) where {H &lt;: AbstractHGNNDiHypergraph}
outdegree(hg::H, inds::AbstractVector{Int}) where {H &lt;: AbstractHGNNDiHypergraph}

Return the outgoing degree of all vertices (if no index is provided) or of a specific group of indices for a
directed hypergraph. The outgoing degree is the number of directed hyperedges containing a vertex in the tail.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L182-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.outneighbors-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph" href="#Graphs.outneighbors-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.outneighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">outneighbors(hg::H; same_side::Bool=false) where {H &lt;: AbstractHGNNDiHypergraph}

Return the outgoing neighbors for a directed hypergraph `hg`. Note that the definition of `outgoing` depends on
if `same_side` is true or false; see below.

Args:
    hg::H where {H &lt;: AbstractHGNNDiHypergraph} : Hypergraph
    same_side::Bool : If true, return the neighbors that share a hyperedge tail with each vertex; i.e., if vertex
    `i` and vertex `j` are both in the tail of some hyperedge `e`, they are outgoing neighbors. If false, instead
    return the neighbors on the opposite side of the hyperedge; i.e., if vertex `i` is in the tail of `e` and vertex
    `j` is in the head of `e`, then `j` is an outgoing neighbor to `i`. Default is false.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L349-L361">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.outneighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNDiHypergraph" href="#Graphs.outneighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNDiHypergraph"><code>Graphs.outneighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">outneighbors(hg::H, i::Int; same_side::Bool=false) where {H &lt;: AbstractHGNNDiHypergraph}

Return the outgoing neighbors for a vertex `i` of a directed hypergraph `hg`. Note that the definition of
`outgoing` depends on if `same_side` is true or false; see below.

Args:
    hg::H where {H &lt;: AbstractHGNNDiHypergraph} : Hypergraph
    i::Int : Vertex index
    same_side::Bool : If true, return the neighbors that share a hyperedge tail with each vertex; i.e., if vertex
    `i` and vertex `j` are both in the tail of some hyperedge `e`, they are outgoing neighbors. If false, instead
    return the neighbors on the opposite side of the hyperedge; i.e., if vertex `i` is in the tail of `e` and vertex
    `j` is in the head of `e`, then `j` is an outgoing neighbor to `i`. Default is false.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L383-L396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.add_hyperedge-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.add_hyperedge-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_hyperedge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_hyperedge(
    hg::HGNNDiHypergraph{T, D},
    features::DataStore;
    vertices_tail::D = D(),
    vertices_head::D = D(),
) where {T &lt;: Real, D &lt;: AbstractDict{Int,T}}

Adds a hyperedge to a given `HGNNDiHypergraph`. Because `HGNNDiHypergraph` is immutable, this creates a new
`HGNNDiHypergraph`. Optionally, existing vertices can be added to the tail and/or head of the hyperedge. The
paramaters `vertices_tail` and `vertices_head` represent dictionaries of vertex identifiers and values stored at
the tail and head of hyperedges, respectively. Note that the `features` DataStore is not optional; however, if `hg`
has no `hedata` (i.e., if `hedata` is nothing), this can be empty.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L1344-L1357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.add_hyperedge-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.add_hyperedge-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_hyperedge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_hyperedge(
    hg::HGNNHypergraph{T, D},
    features::DataStore;
    vertices::D = D(),
) where {T &lt;: Real, D &lt;: AbstractDict{Int,T}}

Adds a hyperedge to a given `HGNNHypergraph`. Because `HGNNHypergraph` is immutable, this creates a new
`HGNNHypergraph`. Optionally, existing vertices can be added to the created hyperedge. The paramater `vertices`
represents a dictionary of vertex identifiers andvalues stored at the hyperedges. Note that the `features`
DataStore is not optional; however, if `hg` has no `hedata` (i.e., if `hedata` is nothing), this can be empty.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L482-L493">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.add_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.add_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_hyperedges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_hyperedges(
    hg::HGNNDiHypergraph{T, D},
    n::Int,
    features::DataStore;
    vertices_tail::AbstractVector{D} = Vector{D}(D(), n),
    vertices_head::AbstractVector{D} = Vector{D}(D(), n)
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Adds a set of hyperedges to a directed hypergraph `hg`. Optionally, the user can specify the vertices that are
incident on these hyperedges.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L1458-L1469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.add_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.add_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_hyperedges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_hyperedges(
    hg::HGNNHypergraph{T, D},
    n::Int,
    features::DataStore;
    vertices::AbstractVector{D} = Vector{D}(D(), n)    
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Adds a set of hyperedges to an undirected hypergraph `hg`. Optionally, the user can specify the vertices that are
incident on these hyperedges.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L366-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.add_selfloops-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.add_selfloops-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_selfloops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_selfloops(
    hg::HGNNDiHypergraph{T, D};
    add_repeated_hyperedge::Bool = false
) where {T&lt;:Real, D&lt;:AbstractDict{Int,T}}

Add self-loops (hyperedges with the tail and the head both containing only a single vertex `v`) to a directed
hypergraph. If `add_repeated_hyperedge` is true (default is false), then new self-loops will be added, even when
a self-loop already exists for some vertex.

NOTE: this function will throw an AssertionError if hg.hedata is not empty</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L48-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.add_selfloops-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.add_selfloops-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_selfloops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_selfloops(
    hg::HGNNHypergraph{T, D};
    add_repeated_hyperedge::Bool = false
) where {T&lt;:Real, D&lt;:AbstractDict{Int,T}}

Add self-loops (hyperedges containing a single vertex) to an undirected hypergraph. If `add_repeated_hyperedge` is
true (default is false), then new self-loops will be added, even when a self-loop already exists for some vertex.

NOTE: this function will throw an AssertionError if hg.hedata is not empty</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.add_vertex-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.add_vertex-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_vertex(
    hg::HGNNDiHypergraph{T, D},
    features::DataStore;
    hyperedges_tail::D = D(),
    hyperedges_head::D = D(),
    hypergraph_id::Int = 1
) where {T &lt;: Real, D &lt;: AbstractDict{Int,T}}

Create a new HGNNDiHypergraph that adds a vertex to an existing directed hypergraph `hg`. Note that the `features`
DataStore is not optional, but if the input hypergraph has no vertex data, this can be empty. Optionally, the
vertex can be added to existing hyperedges. The `hyperedges_tail` and `hyperedges_head` parameters include
dictionaries of hyperedge identifiers and values stored at the hyperedges.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L1144-L1157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.add_vertex-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.add_vertex-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_vertex(
    hg::HGNNHypergraph{T, D},
    features::DataStore;
    hyperedges::D = D(),
    hypergraph_id::Int = 1
) where {T &lt;: Real, D &lt;: AbstractDict{Int,T}}

Create a new HGNNHypergraph that adds a vertex to an existing hypergraph `hg`. Note that the `features` DataStore
is not optional, but if the input hypergraph has no vertex data, this can be empty. Optionally, the vertex can be
added to existing hyperedges. The `hyperedges` parameter presents a dictionary of hyperedge identifiers and values
stored at the hyperedges.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L268-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.add_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.add_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_vertices(
    hg::HGNNDiHypergraph{T, D},
    n::Int,
    features::DataStore;
    hyperedges_tail::AbstractVector{D} = Vector{D}(D(), n),
    hyperedges_head::AbstractVector{D} = Vector{D}(D(), n),
    hypergraph_ids::AbstractVector{Int} = ones(Int, n)
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Adds a set of vertices to an directed hypergraph `hg`. Optionally, the user can specify the hyperedges on which
these vertices are incident.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L1421-L1433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.add_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.add_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.add_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_vertices(
    hg::HGNNHypergraph{T, D},
    n::Int,
    features::DataStore;
    hyperedges::AbstractVector{D} = Vector{D}(D(), n),
    hypergraph_ids::AbstractVector{Int} = ones(Int, n)
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Adds a set of vertices to an undirected hypergraph `hg`. Optionally, the user can specify the hyperedges on which
these vertices are incident.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L337-L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.check_num_hyperedges-Union{Tuple{H}, Tuple{H, AbstractArray}} where H&lt;:AbstractHGNNDiHypergraph" href="#HyperGraphNeuralNetworks.check_num_hyperedges-Union{Tuple{H}, Tuple{H, AbstractArray}} where H&lt;:AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.check_num_hyperedges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_num_hyperedges(hg::H, x::AbstractArray) where {H &lt;: AbstractHGNNDiHypergraph}
check_num_hyperedges(hg::H, x::Union{Tuple, NamedTuple}) where {H &lt;: AbstractHGNNDiHypergraph}

Ensure that an array abstract array, tuple, or named tuple (i.e., tensor) `x` has the appropriate final dimension,
equal to the number of hyperedges in the associated directed hypergraph `hg`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/utils.jl#L61-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.check_num_hyperedges-Union{Tuple{H}, Tuple{H, AbstractArray}} where H&lt;:AbstractHGNNHypergraph" href="#HyperGraphNeuralNetworks.check_num_hyperedges-Union{Tuple{H}, Tuple{H, AbstractArray}} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.check_num_hyperedges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_num_hyperedges(hg::H, x::AbstractArray) where {H &lt;: AbstractHGNNHypergraph}
check_num_hyperedges(hg::H, x::Union{Tuple, NamedTuple}) where {H &lt;: AbstractHGNNHypergraph}

Ensure that an array abstract array, tuple, or named tuple (i.e., tensor) `x` has the appropriate final dimension,
equal to the number of hyperedges in the associated hypergraph `hg`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/utils.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.check_num_vertices-Union{Tuple{H}, Tuple{H, AbstractArray}} where H&lt;:AbstractHGNNDiHypergraph" href="#HyperGraphNeuralNetworks.check_num_vertices-Union{Tuple{H}, Tuple{H, AbstractArray}} where H&lt;:AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.check_num_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_num_vertices(hg::H, x::AbstractArray) where {H &lt;: AbstractHGNNDiHypergraph}
check_num_vertices(hg::H, x::Union{Tuple, NamedTuple}) where {H &lt;: AbstractHGNNDiHypergraph}

Ensure that an array abstract array, tuple, or named tuple (i.e., tensor) `x` has the appropriate final dimension,
equal to the number of vertices in the associated directed hypergraph `hg`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/utils.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.check_num_vertices-Union{Tuple{H}, Tuple{H, AbstractArray}} where H&lt;:AbstractHGNNHypergraph" href="#HyperGraphNeuralNetworks.check_num_vertices-Union{Tuple{H}, Tuple{H, AbstractArray}} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.check_num_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_num_vertices(hg::H, x::AbstractArray) where {H &lt;: AbstractHGNNHypergraph}
check_num_vertices(hg::H, x::Union{Tuple, NamedTuple}) where {H &lt;: AbstractHGNNHypergraph}

Ensure that an array abstract array, tuple, or named tuple (i.e., tensor) `x` has the appropriate final dimension,
equal to the number of vertices in the associated hypergraph `hg`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/utils.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.clique_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.clique_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.clique_negative_sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clique_negative_sample(
    hg::HGNNHypergraph{T, D},
    n::Int,
    rng::AbstractRNG;
    max_trials::Int = 10
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Sample `n` negative hyperedges in an undirected hypergraph `hg` using a random number generator `rng` using the
&quot;clique negative sampling&quot; (CNS) strategy described in Patil et al., &quot;Negative Sampling for Hyperlink Prediction in
Networks&quot;, DOI: 10.1007/978-3-030-47436-2_46 (2020). CNS samples negative hyperedges using the clique-expanded
graph of `hg`, ensuring that the edge density of sampled hyperedges will always be 1. 

It is possible that any given hyperedge generated using clique negative sampling may be a duplicate or may not be a
negative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm
will attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still
possible that less than `n` unique negative hyperedges will be produced.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L1201-L1218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.combine_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, HGNNDiHypergraph{T, D}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.combine_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, HGNNDiHypergraph{T, D}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.combine_hypergraphs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">combine_hypergraphs(
    hg1::HGNNDiHypergraph{T, D},
    hg2::HGNNDiHypergraph{T, D}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

combine_hypergraphs(
    hg1::HGNNDiHypergraph{T,D},
    hgothers::HGNNDiHypergraph{T,D}...
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

combine_hypergraphs(
    hgs::AbstractVector{HGNNDiHypergraph{T,D}}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Merge two (or more) directed hypergraphs into a single hypergraph. This is used for batching (`MLUtils.batch`).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L431-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.combine_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, HGNNHypergraph{T, D}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.combine_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, HGNNHypergraph{T, D}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.combine_hypergraphs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">combine_hypergraphs(
    hg1::HGNNHypergraph{T, D},
    hg2::HGNNHypergraph{T, D}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

combine_hypergraphs(
    hg1::HGNNHypergraph{T,D},
    hgothers::HGNNHypergraph{T,D}...
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

combine_hypergraphs(
    hgs::AbstractVector{HGNNHypergraph{T,D}}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Merge two (or more) undirected hypergraphs into a single hypergraph. This is used for batching (`MLUtils.batch`).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L336-L352">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.complex_incidence_matrix-Tuple{H} where H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph" href="#HyperGraphNeuralNetworks.complex_incidence_matrix-Tuple{H} where H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph"><code>HyperGraphNeuralNetworks.complex_incidence_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complex_incidence_matrix(hg::H) where {H &lt;: AbstractDirectedHypergraph}

Convert the matrix representation of an undirected hypergraph `hg` into a single complex-valued incidence matrix
`M`. The (i,j)-th element of `M` is 1 if vertex `i` is in the head of hyperedge `j`, -im if `i` is in the tail of
`j`, and 0 otherwise. If there are any hyperedges where any vertex is in both the tail and the head, an error is
thrown.

Reference:
    Fiorini, S., Coniglio, S., Ciavotta, M., Del Bue, A., Let There be Direction in Hypergraph Neural Networks.
    Transactions on Machine Learning Research, 2024.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L589-L600">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.erdos_renyi_hypergraph-Union{Tuple{H}, Tuple{Int64, Int64, Type{H}}} where H&lt;:AbstractHGNNHypergraph" href="#HyperGraphNeuralNetworks.erdos_renyi_hypergraph-Union{Tuple{H}, Tuple{Int64, Int64, Type{H}}} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.erdos_renyi_hypergraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">erdos_renyi_hypergraph(
    nVertices::Int,
    nEdges::Int,
    HType::Type{H};
    seed::Int = -1,
    kws...
) where {H &lt;: AbstractHGNNHypergraph}

erdos_renyi_hypergraph(
    nVertices::Int,
    nEdges::Int,
    HType::Type{H};
    seed::Int = -1,
    no_self_loops::Bool = false,
    kws...
) where {H &lt;: AbstractHGNNDiHypergraph}

Generate a *random* hypergraph (in the style of Erdős–Rényi random graphs) without any structural
constraints. See `SimpleHypergraphs.random_model`. The user can optionally seed the random number
generator with kwarg `seed`. The default value is -1; if the value is greater than or equal to 0, then `seed` will
be used.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/generate.jl#L2-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.get_hyperedge_weight-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNDiHypergraph" href="#HyperGraphNeuralNetworks.get_hyperedge_weight-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.get_hyperedge_weight</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hyperedge_weight(hg::H, he_ind::Int; side::Symbol = :both) where {H &lt;: AbstractHGNNDiHypergraph}
get_hyperedge_weight(hg::H, he_ind::Int, op::Function; side::Symbol = :both) where {H &lt;: AbstractHGNNDiHypergraph}

Obtain the non-`nothing` weights associated with a directed hyperedge in `hg` given by index `he_ind`. See
`get_hyperedge_weights` for more detail.

TODO: add check for array bounds</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L101-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.get_hyperedge_weight-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNHypergraph" href="#HyperGraphNeuralNetworks.get_hyperedge_weight-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.get_hyperedge_weight</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hyperedge_weight(hg::H, he_ind::Int) where {H &lt;: AbstractHGNNHypergraph}
get_hyperedge_weight(hg::H, he_ind::Int, op::Function) where {H &lt;: AbstractHGNNHypergraph}

Obtain the non-`nothing` weights associated with a hyperedge in `hg` given by index `he_ind`. See
`get_hyperedge_weights` for more detail

TODO: add check for array bounds</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.get_hyperedge_weights-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph" href="#HyperGraphNeuralNetworks.get_hyperedge_weights-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.get_hyperedge_weights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hyperedge_weights(hg::H; side::Symbol = :both) where {H &lt;: AbstractHGNNDiHypergraph}
get_hyperedge_weights(hg::H, op::Function; side::Symbol = :both) where {H &lt;: AbstractHGNNDiHypergraph}

Return the weights of a directed hypergraph `hg`. The user can choose to obtain the weights of the hyperedge tails
(`side=:tail`), the heads (`side=:head`), or both (`side=:both`). The tail weights and head weights are both
vectors of vectors, where the `i`th element of one such vector corresponds to the non-`nothing` weights of the tail
or head of the `i`th hyperedge. If function `op` is provided, then the weights are transformed using `op` before
being returned. Note that `op` should take only one argument.

TODO: how to handle case where user wants a single weight value per hyperedge, using :both?</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L65-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.get_hyperedge_weights-Tuple{H} where H&lt;:AbstractHGNNHypergraph" href="#HyperGraphNeuralNetworks.get_hyperedge_weights-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.get_hyperedge_weights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hyperedge_weights(hg::H) where {H &lt;: AbstractHGNNHypergraph}
get_hyperedge_weights(hg::H, op::Function) where {H &lt;: AbstractHGNNHypergraph}

Get the weights of each hyperedge in the hypergraph `hg`. This function returns a vector of vectors, where each
element contains the non-`nothing` weights of the associated hyperedge. If the function `op` is provided, then
the weights are transformed using `op` before being returned. Note that `op` should take only one argument.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.get_hypergraph-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.get_hypergraph-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.get_hypergraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hypergraph(hg::HGNNDiHypergraph, i::Int; kws...)

get_hypergraph(hg::HGNNDiHypergraph, i::AbstractVector{Int}; map_vertices::Bool = false)

Extract one or more hypergraphs (based on `hypergraph_ids`) from an `HGNNHypergraph` containing multiple
hypergraphs. This is used for unbatching (`MLUtils.unbatch`).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L651-L658">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.get_hypergraph-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.get_hypergraph-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.get_hypergraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hypergraph(hg::HGNNHypergraph, i::Int; kws...)

get_hypergraph(hg::HGNNHypergraph, i::AbstractVector{Int}; map_vertices::Bool = false)

Extract one or more hypergraphs (based on `hypergraph_ids`) from an `HGNNHypergraph` containing multiple
hypergraphs. This is used for unbatching (`MLUtils.unbatch`).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L561-L569">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.has_multi_hyperedges-Tuple{H} where H&lt;:AbstractHGNNHypergraph" href="#HyperGraphNeuralNetworks.has_multi_hyperedges-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.has_multi_hyperedges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_multi_hyperedges(hg::H) where {H &lt;: AbstractHGNNHypergraph}
has_multi_hyperedges(hg::H) where {H &lt;: AbstractHGNNDiHypergraph}

Checks if there are any hyperedges with multiplicity greater than 1, i.e., if there are two or more hyperedges
containing identical vertices. For directed hyperedges, both the tail vertices and the head vertices have to be
identical to be considered duplicates.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L863-L870">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.hyperedge_degree_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph" href="#HyperGraphNeuralNetworks.hyperedge_degree_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_degree_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hyperedge_degree_matrix(hg::H) where {H &lt;: AbstractSimpleHypergraph}
hyperedge_degree_matrix(hg::H) where {H &lt;: AbstractDirectedHypergraph}

An `ExE` matrix (where `E` is the number of hyperedges in `hg`) where the diagonal element `(i,i)` is the degree of
hyperedge `i` and all other elements are 0. For directed hypergraphs, two degree matrices are provided: one with
diagonal elements equal to the number of vertices in the tail of each hyperedge and the other with diagonal
elements equal to the number of vertices in the head of each hyperedge.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L711-L719">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.hyperedge_index-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph" href="#HyperGraphNeuralNetworks.hyperedge_index-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hyperedge_index(hg::H) where {H &lt;: AbstractHGNNHypergraph}

Obtain the hyperedge index of a directed hypergraph `hg`. The index is returned as two vectors of vectors, one for
the hyperedge tails and the other for the hyperedge heads. The `i`th element of `ind_tail` contains the indices of
the vertices present in the tail of hyperedge `i`, and likewise, the `i`th element of `ind_head` contains the
indices of the vertices in the head of hyperedge `i`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.hyperedge_index-Tuple{H} where H&lt;:AbstractHGNNHypergraph" href="#HyperGraphNeuralNetworks.hyperedge_index-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hyperedge_index(hg::H) where {H &lt;: AbstractHGNNHypergraph}

Obtain the hyperedge index of an undirected hypergraph `hg`. The index is a vector of vectors, where the `i`th
element of the index contains the indices of all vertices present in hyperedge `i`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.hyperedge_neighbors-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph" href="#HyperGraphNeuralNetworks.hyperedge_neighbors-Tuple{H} where H&lt;:AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_neighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hyperedge_neighbors(hg::H; directed::Bool=false) where {H &lt;: AbstractHGNNDiHypergraph}

Returns the neighbors of each hyperedge in directed hypergraph `hg`. If `directed` is true (default false), then
hyperedge `i` is neighbors with hyperedge `j` if and only if there is at least one vertex in the head of `i` that
is also in the tail of `j`. Otherwise, two hyperedges are neighbors if they share any vertices, irrespective of
whether those vertices are in the hyperedges&#39; heads or tails.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L463-L470">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.hyperedge_neighbors-Tuple{H} where H&lt;:AbstractHGNNHypergraph" href="#HyperGraphNeuralNetworks.hyperedge_neighbors-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_neighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hyperedge_neighbors(hg::H) where {H &lt;: AbstractHGNNHypergraph}

Returns the neighbors of each hyperedge in an undirected hypergraph `hg`. A hyperedge `e` is neighbors with a
hyperedge `f` if there is at least one vertex contained in both `e` and `f`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L415-L421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.hyperedge_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNDiHypergraph" href="#HyperGraphNeuralNetworks.hyperedge_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNDiHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_neighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hyperedge_neighbors(hg::H, i::Int; directed::Bool=false) where {H &lt;: AbstractHGNNDiHypergraph}

Returns the neighbors of hyperedge `i` in directed hypergraph `hg`. If `directed` is true (default false), then
hyperedge `i` is neighbors with hyperedge `j` if and only if there is at least one vertex in the head of `i` that
is also in the tail of `j`. Otherwise, two hyperedges are neighbors if they share any vertices, irrespective of
whether those vertices are in the hyperedges&#39; heads or tails.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L509-L516">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.hyperedge_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNHypergraph" href="#HyperGraphNeuralNetworks.hyperedge_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_neighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hyperedge_neighbors(hg::H, i::Int) where {H &lt;: AbstractHGNNHypergraph}

Returns the neighbors of hyperedge `i` in an undirected hypergraph `hg`. A hyperedge `i` is neighbors with a
hyperedge `e` if there is at least one vertex contained in both `i` and `e`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L439-L445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.hyperedge_weight_matrix-Tuple{H} where H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph" href="#HyperGraphNeuralNetworks.hyperedge_weight_matrix-Tuple{H} where H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_weight_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hyperedge_weight_matrix(h::H; weighting_function::Function=sum) where {H &lt;: AbstractDirectedHypergraph}

Return two NxN diagonal weight matrices for the directed hypergraph `hg`, where N is the number of hyperedges in
`hg`. One matrix is based on the hyperedge tails, and the other is based on the hyperedge heads. Because
SimpleHypergraphs hypergraphs can have different weights for each vertex-hyperedge pair, the weight of a hyperedge
is ambiguous. The user can specify a `weighting_function` (default is `sum`) that operates on each row of the
hypergraph tail/head weighted incidence matrix.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L672-L680">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.hyperedge_weight_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph" href="#HyperGraphNeuralNetworks.hyperedge_weight_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph"><code>HyperGraphNeuralNetworks.hyperedge_weight_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hyperedge_weight_matrix(hg::H; weighting_function::Function=sum) where {H &lt;: AbstractSimpleHypergraph}

Return an NxN diagonal weight matrix for the undirected hypergraph `hg`, where N is the number of hyperedges in
`hg`. Because SimpleHypergraphs hypergraphs can have different weights for each vertex-hyperedge pair, the weight
of a hyperedge is ambiguous. The user can specify a `weighting_function` (default is `sum`) that operates on each
column of the hypergraph weighted incidence matrix.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L632-L639">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.hypergraph_ids-Tuple{H} where H&lt;:AbstractHGNNHypergraph" href="#HyperGraphNeuralNetworks.hypergraph_ids-Tuple{H} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.hypergraph_ids</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hypergraph_ids(hg::H) where {H &lt;: AbstractHGNNHypergraph}
hypergraph_ids(hg::H) where {H &lt;: AbstractHGNNDiHypergraph}

Returns a vector containing the graph membership of each vertex in the hypergraph `hg`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L823-L828">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.motif_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.motif_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.motif_negative_sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">motif_negative_sample(
    hg::HGNNHypergraph{T, D},
    n::Int,
    rng::AbstractRNG;
    max_trials::Int = 10
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Sample `n` negative hyperedges in a directed hypergraph `hg` using a random number generator `rng` using the
&quot;motif negative sampling&quot; (MNS) strategy described in Patil et al., &quot;Negative Sampling for Hyperlink Prediction in
Networks&quot;, DOI: 10.1007/978-3-030-47436-2_46 (2020). MNS samples in such a way as to approximate the edge-density
distribution of hyperedges in `hg`. Note that MNS was not tested on directed hypergraphs in Patil et al., and it
is possible that this algorithm does not produce the same or similar edge-density distributions to the hyperedge
set in `hg`.

It is possible that any given hyperedge generated using motif negative sampling may be a duplicate or may not be a
negative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm
will attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still
possible that less than `n` unique negative hyperedges will be produced.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L1108-L1127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.motif_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.motif_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.motif_negative_sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">motif_negative_sample(
    hg::HGNNHypergraph{T, D},
    n::Int,
    rng::AbstractRNG;
    max_trials::Int = 10
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Sample `n` negative hyperedges in an undirected hypergraph `hg` using a random number generator `rng` using the
&quot;motif negative sampling&quot; (MNS) strategy described in Patil et al., &quot;Negative Sampling for Hyperlink Prediction in
Networks&quot;, DOI: 10.1007/978-3-030-47436-2_46 (2020). MNS samples in such a way as to approximate the edge-density
distribution of hyperedges in `hg`. 

It is possible that any given hyperedge generated using motif negatiive sampling may be a duplicate or may not be a
negative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm
will attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still
possible that less than `n` unique negative hyperedges will be produced.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L1031-L1048">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.negative_sample_hyperedge-Union{Tuple{S}, Tuple{H}, Tuple{H, Int64, Random.AbstractRNG, S}} where {H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph, S&lt;:AbstractNegativeSamplingStrategy}" href="#HyperGraphNeuralNetworks.negative_sample_hyperedge-Union{Tuple{S}, Tuple{H}, Tuple{H, Int64, Random.AbstractRNG, S}} where {H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph, S&lt;:AbstractNegativeSamplingStrategy}"><code>HyperGraphNeuralNetworks.negative_sample_hyperedge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">negative_sample_hyperedge(
    hg::H,
    n::Int,
    rng::AbstractRNG,
    ::S;
    max_trials::Int = 10
) where {H &lt;: AbstractDirectedHypergraph, S &lt;: AbstractNegativeSamplingStrategy}

Sample `n` negative hyperedges in a directed hypergraph `hg` using a random number generator `rng` using the
sampling strategy of type `S &lt;: AbstractNegativeSamplingStrategy`. Currently, uniform sampling
(`uniform_negative_sample`), sized negative sampling (`sized_negative_sample`), and motif negative sampling
(`motif_negative_sample`) are implemented.

It is possible that any given hyperedge generated using this function may be a duplicate or may not be a
negative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm
will attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still
possible that less than `n` unique negative hyperedges will be produced.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L1316-L1335">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.negative_sample_hyperedge-Union{Tuple{S}, Tuple{H}, Tuple{H, Int64, Random.AbstractRNG, S}} where {H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph, S&lt;:AbstractNegativeSamplingStrategy}" href="#HyperGraphNeuralNetworks.negative_sample_hyperedge-Union{Tuple{S}, Tuple{H}, Tuple{H, Int64, Random.AbstractRNG, S}} where {H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph, S&lt;:AbstractNegativeSamplingStrategy}"><code>HyperGraphNeuralNetworks.negative_sample_hyperedge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">negative_sample_hyperedge(
    hg::H,
    n::Int,
    rng::AbstractRNG,
    ::S;
    max_trials::Int = 10
) where {H &lt;: AbstractSimpleHypergraph, S &lt;: AbstractNegativeSamplingStrategy}

Sample `n` negative hyperedges in an undirected hypergraph `hg` using a random number generator `rng` using the
sampling strategy of type `S &lt;: AbstractNegativeSamplingStrategy`. Currently, uniform sampling
(`uniform_negative_sample`), sized negative sampling (`sized_negative_sample`), motif negative sampling
(`motif_negative_sample`), and clique negative sampling (`clique_negative_sample`) are implemented.

It is possible that any given hyperedge generated using this function may be a duplicate or may not be a
negative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm
will attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still
possible that less than `n` unique negative hyperedges will be produced.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L1277-L1295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.normalized_laplacian_matrix-Tuple{H} where H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph" href="#HyperGraphNeuralNetworks.normalized_laplacian_matrix-Tuple{H} where H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph"><code>HyperGraphNeuralNetworks.normalized_laplacian_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalized_laplacian_matrix(
    h::H;
    weighting_function::Function=sum,
    combining_function::Function=_matrix_avg
)

Returns the normalized Laplacian for an undirected hypergraph `hg`.

Because of the ambiguity of defining hyperedge weight in the SimpleHypergraphs formalism, the user can
specify a `weighting_function` that, for each hyperedge, acts on the associated row of the matrix representation of
`hg`; the default is `sum`. The user can also specify a `combining_function` for how the hyperedge tail and head
weights should be combined to a single matrix; the default is to average the two matrices.

Ln = I - Qn,
Qn = Dv^(-1/2) A W De^(-1) A* Dv^(-1/2),

where
    Ln = normalized signed Laplacian (MxM)
    I = identity matrix (MxM)
    Qn = normalized Laplacian (MxM)
    Dv = vertex degree matrix (MxM) &lt;-- obtained by summing the tail and head degree matrices
    De = hyperedge degree matrix (NxN) &lt;-- obtained by summing the tail and head degree matrices
    A = incidence matrix (MxN)
    A* = conjugate transpose of A (NxM)
    W = hyperedge weight matrix (NxN) &lt;-- obtained by applying `combining_function` (default: averaging) to the
        tail and head weight matrices

    M = # vertices in `hg`
    N = # hyperedges in `hg`

Reference:
    Fiorini, S., Coniglio, S., Ciavotta, M., Del Bue, A., Let There be Direction in Hypergraph Neural Networks.
    Transactions on Machine Learning Research, 2024.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L769-L803">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.normalized_laplacian_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph" href="#HyperGraphNeuralNetworks.normalized_laplacian_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph"><code>HyperGraphNeuralNetworks.normalized_laplacian_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalized_laplacian_matrix(hg::H; weighting_function::Function=sum) where {H &lt;: AbstractSimpleHypergraph}

Returns the normalized Laplacian for an undirected hypergraph `hg`.

Because of the ambiguity of defining hyperedge weight in the SimpleHypergraphs formalism, the user can
specify a `weighting_function` that, for each hyperedge, acts on the associated row of the matrix representation of
`hg`; the default is `sum`.

Ln = I - Qn,
Qn = Dv^(-1/2) A W De^(-1) A* Dv^(-1/2),

where
    Ln = normalized signed Laplacian (MxM)
    I = identity matrix (MxM)
    Qn = normalized Laplacian (MxM)
    Dv = vertex degree matrix (MxM)
    De = hyperedge degree matrix (NxN)
    A = incidence matrix (MxN)
    A* = transpose of A (NxM)
    W = hyperedge weight matrix (NxN)

    M = # vertices in `hg`
    N = # hyperedges in `hg`

Reference:
    Fiorini, S., Coniglio, S., Ciavotta, M., Del Bue, A., Let There be Direction in Hypergraph Neural Networks.
    Transactions on Machine Learning Research, 2024.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L727-L755">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.print_all_features-Tuple{IO, Any, Any, Any}" href="#HyperGraphNeuralNetworks.print_all_features-Tuple{IO, Any, Any, Any}"><code>HyperGraphNeuralNetworks.print_all_features</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">print_all_features(io::IO, vdata, hedata, hgdata)
Helper function that reports the vertex, hyperedge, and hypergraph features of a hypergraph.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L723-L726">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.random_dregular_hypergraph-Union{Tuple{H}, Tuple{Int64, Int64, Int64, Type{H}}} where H&lt;:AbstractHGNNHypergraph" href="#HyperGraphNeuralNetworks.random_dregular_hypergraph-Union{Tuple{H}, Tuple{Int64, Int64, Int64, Type{H}}} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.random_dregular_hypergraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_dregular_hypergraph(
    nVertices::Int,
    nEdges::Int,
    d::Int,
    HType::Type{H};
    seed::Int = -1,
    kws...
) where {H &lt;: AbstractHGNNHypergraph}

random_dregular_hypergraph(
    nVertices::Int,
    nEdges::Int,
    d::Int,
    HType::Type{H};
    seed::Int = -1,
    no_self_loops::Bool = false,
    kws...
) where {H &lt;: AbstractHGNNDiHypergraph}

Generates a *d*-regular hypergraph, where each node has degree *d*. See `SimpleHypergraphs.random_dregular_model`.
The user can optionally seed the random number generator with kwarg `seed`. The default value is -1; if the value
is greater than or equal to 0, then `seed` will be used.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/generate.jl#L129-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.random_kuniform_hypergraph-Union{Tuple{H}, Tuple{Int64, Int64, Int64, Type{H}}} where H&lt;:AbstractHGNNHypergraph" href="#HyperGraphNeuralNetworks.random_kuniform_hypergraph-Union{Tuple{H}, Tuple{Int64, Int64, Int64, Type{H}}} where H&lt;:AbstractHGNNHypergraph"><code>HyperGraphNeuralNetworks.random_kuniform_hypergraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_kuniform_hypergraph(
    nVertices::Int,
    nEdges::Int,
    k::Int,
    HType::Type{H};
    seed::Int = -1,
    kws...
) where {H &lt;: AbstractHGNNHypergraph}

random_kuniform_hypergraph(
    nVertices::Int,
    nEdges::Int,
    k::Int,
    HType::Type{H};
    seed::Int = -1,
    no_self_loops::Bool = false,
    kws...
) where {H &lt;: AbstractHGNNDiHypergraph}

Generates a *k*-uniform hypergraph, i.e. an hypergraph where each hyperedge has size *k*. For a directed hypergraph,
each hyperedge has size *k = k_tail + k_head*, where *k_tail* and *k_head* are not necessarily equal. See 
`SimpleHypergraphs.random_kuniform_model`. The user can optionally seed the random number generator with kwarg
`seed`. The default value is -1; if the value is greater than or equal to 0, then `seed` will be used.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/generate.jl#L63-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.random_preferential_hypergraph-Union{Tuple{HO}, Tuple{HI}, Tuple{Int64, Real, Type{HO}}} where {HI&lt;:SimpleHypergraphs.AbstractSimpleHypergraph, HO&lt;:AbstractHGNNHypergraph}" href="#HyperGraphNeuralNetworks.random_preferential_hypergraph-Union{Tuple{HO}, Tuple{HI}, Tuple{Int64, Real, Type{HO}}} where {HI&lt;:SimpleHypergraphs.AbstractSimpleHypergraph, HO&lt;:AbstractHGNNHypergraph}"><code>HyperGraphNeuralNetworks.random_preferential_hypergraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_preferential_hypergraph(
    nVertices::Int,
    p::Real,
    HType::Type{HO};
    seed::Int = -1,
    HTypeStart::Type{HI} = Hypergraph,
    hg::HI = random_model(5,5, HI),
    kws...
) where {HI&lt;:AbstractSimpleHypergraph, HO&lt;:AbstractHGNNHypergraph}

Generate a hypergraph with a preferential attachment rule between nodes, as presented in
*Avin, C., Lotker, Z., and Peleg, D. Random preferential attachment hyper-graphs. Computer Science 23 (2015).*
See `SimpleHypergraphs.random_preferential_model` for more details. The user can optionally seed the random number
generator with kwarg `seed`. The default value is -1; if the value is greater than or equal to 0, then `seed` will
be used.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/generate.jl#L194-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.random_split_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{&lt;:Real}, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.random_split_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{&lt;:Real}, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.random_split_hyperedges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_split_hyperedges(
    hg::HGNNHypergraph{T,D},
    fracs::AbstractVector{&lt;:Real},
    rng::AbstractRNG
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

random_split_hyperedges(
    hg::HGNNDiHypergraph{T,D},
    fracs::AbstractVector{&lt;:Real},
    rng::AbstractRNG
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Randomly partition a hypergraph `hg` by dividing the hyperedges (see `split_hyperedges`). Users provide the
(relative) sizes of the partitions via `fracs`, a vector of real numbers. The sum of the fractions must equal 1,
and all fractions must be between 0 and 1. Users must additionally provide a random number generator (`rng`).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/split.jl#L1123-L1139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.random_split_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{&lt;:Real}, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.random_split_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{&lt;:Real}, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.random_split_hypergraphs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_split_hypergraphs(
    hg::HGNNHypergraph{T,D},
    fracs::AbstractVector{&lt;:Real},
    rng::AbstractRNG
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

random_split_hypergraphs(
    hg::HGNNDiHypergraph{T,D},
    fracs::AbstractVector{&lt;:Real},
    rng::AbstractRNG
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Randomly partition a hypergraph `hg` by dividing the (sub)-hypergraphs (see `split_hypergraphs`). Users provide the
(relative) sizes of the partitions via `fracs`, a vector of real numbers. The sum of the fractions must equal 1,
and all fractions must be between 0 and 1. Users must additionally provide a random number generator (`rng`).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/split.jl#L1196-L1212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.random_split_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{&lt;:Real}, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.random_split_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{&lt;:Real}, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.random_split_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_split_vertices(
    hg::HGNNHypergraph{T,D},
    fracs::AbstractVector{&lt;:Real},
    rng::AbstractRNG
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

random_split_vertices(
    hg::HGNNDiHypergraph{T,D},
    fracs::AbstractVector{&lt;:Real},
    rng::AbstractRNG
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Randomly partition a hypergraph `hg` by dividing the vertices (see `split_vertices`). Users provide the (relative)
sizes of the partitions via `fracs`, a vector of real numbers. The sum of the fractions must equal 1, and all
fractions must be between 0 and 1. Users must additionally provide a random number generator (`rng`).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/split.jl#L1050-L1066">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.remove_hyperedge-Tuple{HGNNHypergraph, Int64}" href="#HyperGraphNeuralNetworks.remove_hyperedge-Tuple{HGNNHypergraph, Int64}"><code>HyperGraphNeuralNetworks.remove_hyperedge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_hyperedge(hg::HGNNHypergraph, e::Int)

Removes the hyperedge `e` from a given undirected HGNNHypergraph `hg`. Note that this function creates a new
HGNNHypergraph.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L554-L559">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.remove_hyperedge-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.remove_hyperedge-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.remove_hyperedge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_hyperedge(hg::HGNNDiHypergraph, e::Int)</code></pre><p>Removes the hyperedge <code>e</code> from a given undirected HGNNDiHypergraph <code>hg</code>. Note that this function creates a new HGNNDiHypergraph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L1501-L1506">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.remove_hyperedges-Tuple{HGNNHypergraph, AbstractVector{Int64}}" href="#HyperGraphNeuralNetworks.remove_hyperedges-Tuple{HGNNHypergraph, AbstractVector{Int64}}"><code>HyperGraphNeuralNetworks.remove_hyperedges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_hyperedges(hg::HGNNHypergraph, to_remove::AbstractVector{Int})

Removes a set of hyperedges (`to_remove`) from an undirected hypergraph `hg` by index
Note that the index of v2he will be shifted down after the hyperedges removal.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L650-L655">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.remove_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{Int64}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.remove_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{Int64}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.remove_hyperedges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_hyperedges(hg::HGNNDiHypergraph, to_remove::AbstractVector{Int})

Removes a set of hyperedges (`to_remove`) from a directed hypergraph `hg` by index
Note that the index of both v2he_tail and v2he_head will be shifted down after 
the vertices removal.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L1655-L1661">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.remove_multihyperedges-Tuple{HGNNHypergraph}" href="#HyperGraphNeuralNetworks.remove_multihyperedges-Tuple{HGNNHypergraph}"><code>HyperGraphNeuralNetworks.remove_multihyperedges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_multihyperedges(hg::HGNNHypergraph)

Remove duplicate hyperedges (hyperedges containing identical vertices) from an undirected hypergraph `hg`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L198-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.remove_multihyperedges-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.remove_multihyperedges-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.remove_multihyperedges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_multihyperedges(hg::HGNNHypergraph)

Remove duplicate hyperedges, i.e., hyperedges ei = (ti, hi), ej = (tj, hj), where t represents a hyperedge tail, h
represents a hyperedge head, and ti = tj and hi = hj, from a directed hypergraph `hg`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L239-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.remove_selfloops-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.remove_selfloops-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.remove_selfloops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_selfloops(hg::HGNNDiHypergraph{T, D}) where {T&lt;:Real, D&lt;:AbstractDict{Int,T}}

Remove self-loops (hyperedges where the tail and head both contain only a single, shared vertex `v`) from a
directed hypergraph `hg`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L148-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.remove_selfloops-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.remove_selfloops-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.remove_selfloops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_selfloops(hg::HGNNHypergraph{T, D}) where {T&lt;:Real, D&lt;:AbstractDict{Int,T}}

Remove self-loops (hyperedges containing only one vertex) from an undirected hypergraph `hg`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.remove_vertex-Tuple{HGNNHypergraph, Int64}" href="#HyperGraphNeuralNetworks.remove_vertex-Tuple{HGNNHypergraph, Int64}"><code>HyperGraphNeuralNetworks.remove_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_vertex(hg::HGNNHypergraph, v::Int)

Removes the vertex `v` from a given `HGNNHypergraph` `hg`. Note that this creates a new HGNNHypergraph, as
HGNNHypergraph objects are immutable.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L408-L413">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.remove_vertex-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.remove_vertex-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.remove_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_vertex(hg::HGNNDiHypergraph, v::Int)

Removes the vertex `v` from a given `HGNNDiHypergraph` `hg`. Note that this creates a new HGNNDiHypergraph, as
HGNNDiHypergraph objects are immutable.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L1248-L1253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.remove_vertices-Tuple{HGNNHypergraph, AbstractVector{Int64}}" href="#HyperGraphNeuralNetworks.remove_vertices-Tuple{HGNNHypergraph, AbstractVector{Int64}}"><code>HyperGraphNeuralNetworks.remove_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_vertices(hg::HGNNHypergraph, to_remove::AbstractVector{Int})

Removes a set of vertices (`to_remove`) from an undirected hypergraph `hg` by index
Note that the index of he2v will be shifted down after the vertices removal.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L603-L608">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.remove_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{Int64}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.remove_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{Int64}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.remove_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_vertices(hg::HGNNDiHypergraph, to_remove::AbstractVector{Int})

Removes a set of vertices (`to_remove`) from a directed hypergraph `hg` by index
Note that the index of both he2v_tail and he2v_head will be shifted down after 
the vertices removal.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L1583-L1589">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.sized_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.sized_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.sized_negative_sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sized_negative_sample(
    hg::HGNNDiHypergraph{T, D},
    n::Int,
    rng::AbstractRNG;
    max_trials::Int = 10
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Sample `n` negative hyperedges in a directed hypergraph `hg` using a random number generator `rng` in such a way
as to ensure that the size distribution of negative hyperedges generated approximately matches that of hyperedges
in `hg`. Specifically, this algorithm samples hypergraphs with total size `|e| = |e_tail| + |e_head|` based on the
total size distribution in the hyperedge set of `hg` and further samples the tail sizes `|e_tail|` based on the
tail size distribution in the hyperedge set of `hg`. 

It is possible that any given hyperedge generated using sized sampling may be a duplicate or may not be a
negative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm
will attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still
possible that less than `n` unique negative hyperedges will be produced.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L957-L975">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.sized_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.sized_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.sized_negative_sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sized_negative_sample(
    hg::HGNNHypergraph{T, D},
    n::Int,
    rng::AbstractRNG;
    max_trials::Int = 10
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Sample `n` negative hyperedges in an undirected hypergraph `hg` using a random number generator `rng` in such a way
as to ensure that the size distribution of negative hyperedges generated approximately matches that of hyperedges
in `hg`.

It is possible that any given hyperedge generated using sized sampling may be a duplicate or may not be a
negative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm
will attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still
possible that less than `n` unique negative hyperedges will be produced.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L902-L918">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.split_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.split_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.split_hyperedges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_hyperedges(
    hg::HGNNDiHypergraph{T,D},
    masks::AbstractVector{BitVector}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

split_hyperedges(
    hg::HGNNDiHypergraph{T, D},
    train_mask::BitVector,
    test_mask::BitVector;
    val_mask::Union{BitVector, Nothing} = nothing,
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

split_hyperedges(
    hg::HGNNDiHypergraph{T,D},
    index_groups::AbstractVector{V}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}, V &lt;: AbstractVector{Int}}

split_hyperedges(
    hg::HGNNDiHypergraph{T,D},
    train_inds::AbstractVector{Int},
    test_inds::AbstractVector{Int};
    val_inds::Union{AbstractVector{Int}, Nothing} = nothing
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Split a single `HGNNDiHypergraph` into an arbitrary number of `HGNNDiHypergraph`s by partitioning hyperedges. This
will also partition vertices and hypergraphs. If a vertex is not incident on any hyperedge in a particular
partition, then that vertex and its associated features will not be present in the resulting `HGNNDiHypergraph`.
Similarly, if no relevant vertex in the partition belongs to a particular sub-hypergraph (based on
`hypergraph_id`s), then that hypergraph and its associated features will not be present in the resulting
`HGNNDiHypergraph`.

Users can provide partitions as `BitVector` masks (length `E`, where `E` is the number of hyperedges) or vectors of
indices (which will be converted into masks). To facilitate train-val-test splits, users can specify which
mask/indices correspond to the train set, test set, and (optionally) validation set. In these cases, the output of
`split_vertices` will be a `NamedTuple` with keys &quot;train&quot;, &quot;test&quot;, and (optionally) &quot;val&quot; and values of
`HGNNDiHypergraph`s; otherwise, the output is a vector of `HGNNDiHypergraph`s.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/split.jl#L526-L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.split_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.split_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.split_hyperedges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_hyperedges(
    hg::HGNNHypergraph{T,D},
    masks::AbstractVector{BitVector}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

split_hyperedges(
    hg::HGNNHypergraph{T, D},
    train_mask::BitVector,
    test_mask::BitVector;
    val_mask::Union{BitVector, Nothing} = nothing,
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

split_hyperedges(
    hg::HGNNHypergraph{T,D},
    index_groups::AbstractVector{V}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}, V &lt;: AbstractVector{Int}}

split_hyperedges(
    hg::HGNNHypergraph{T,D},
    train_inds::AbstractVector{Int},
    test_inds::AbstractVector{Int};
    val_inds::Union{AbstractVector{Int}, Nothing} = nothing
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Split a single `HGNNHypergraph` into an arbitrary number of `HGNNHypergraph`s by partitioning hyperedges. This will
also partition vertices and hypergraphs. If a vertex is not incident on any hyperedge in a particular partition,
then that vertex and its associated features will not be present in the resulting `HGNNHypergraph`. If none of the
relevant vertices in a partition belong to a particular sub-hypergraph (based on `hypergraph_id`s), then that
hypergraph and its associated features will not be present in the resulting `HGNNHypergraph`.

Users can provide partitions as `BitVector` masks (length `E`, where `E` is the number of hyperedges) or vectors
of indices (which will be converted into masks). To facilitate train-val-test splits, users can specify which
mask/indices correspond to the train set, test set, and (optionally) validation set. In these cases, the output
of `split_vertices` will be a `NamedTuple` with keys &quot;train&quot;, &quot;test&quot;, and (optionally) &quot;val&quot; and values of
`HGNNHypergraph`s; otherwise, the output is a vector of `HGNNHypergraph`s.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/split.jl#L354-L390">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.split_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.split_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.split_hypergraphs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_hypergraphs(
    hg::HGNNDiHypergraph{T,D},
    masks::AbstractVector{BitVector}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

split_hypergraphs(
    hg::HGNNDiHypergraph{T,D},
    train_mask::BitVector,
    test_mask::BitVector;
    val_mask::Union{BitVector, Nothing} = nothing,
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

split_hypergraphs(
    hg::HGNNDiHypergraph{T,D},
    index_groups::AbstractVector{V}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}, V &lt;: AbstractVector{Int}}

split_hypergraphs(
    hg::HGNNDiHypergraph{T,D},
    train_inds::AbstractVector{Int},
    test_inds::AbstractVector{Int};
    val_inds::Union{AbstractVector{Int}, Nothing} = nothing
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Split a single `HGNNDiHypergraph` into an arbitrary number of `HGNNDiHypergraph`s by partitioning hypergraphs (from
vertex `hypergraph_id`s). This will also partition vertices and hyperedges. If a vertex&#39;s `hypergraph_id` is not
included in the partition, then that vertex and its associated features will not be present in the resulting
`HGNNDiHypergraph`. If none of the relevant vertices in a partition are incident on a particular hyperedge, then
that hyperedge and its associated features will not be present in the resulting `HGNNDiHypergraph`.

Users can provide partitions as `BitVector` masks (length `G`, where `G` is the number of hypergraphs in this
`HGNNDiHypergraph`) or vectors of indices (which will be converted into masks). To facilitate train-val-test
splits, users can specify which mask/indices correspond to the train set, test set, and (optionally) validation
set. In these cases, the output of `split_vertices` will be a `NamedTuple` with keys &quot;train&quot;, &quot;test&quot;, and
(optionally) &quot;val&quot; and values of `HGNNDiHypergraph`s; otherwise, the output is a vector of `HGNNDiHypergraph`s.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/split.jl#L875-L911">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.split_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.split_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.split_hypergraphs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_hypergraphs(
    hg::HGNNHypergraph{T,D},
    masks::AbstractVector{BitVector}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

split_hypergraphs(
    hg::HGNNHypergraph{T,D},
    train_mask::BitVector,
    test_mask::BitVector;
    val_mask::Union{BitVector, Nothing} = nothing,
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

split_hypergraphs(
    hg::HGNNHypergraph{T,D},
    index_groups::AbstractVector{V}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}, V &lt;: AbstractVector{Int}}

split_hypergraphs(
    hg::HGNNHypergraph{T,D},
    train_inds::AbstractVector{Int},
    test_inds::AbstractVector{Int};
    val_inds::Union{AbstractVector{Int}, Nothing} = nothing
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Split a single `HGNNHypergraph` into an arbitrary number of `HGNNHypergraph`s by partitioning hypergraphs (from
vertex `hypergraph_id`s). This will also partition vertices and hyperedges. If a vertex&#39;s `hypergraph_id` is not
included in the partition, then that vertex and its associated features will not be present in the resulting
`HGNNHypergraph`. If none of the relevant vertices in a partition are incident on a particular hyperedge, then that
hyperedge and its associated features will not be present in the resulting `HGNNHypergraph`.

Users can provide partitions as `BitVector` masks (length `G`, where `G` is the number of hypergraphs in this
`HGNNHypergraph`) or vectors of indices (which will be converted into masks). To facilitate train-val-test
splits, users can specify which mask/indices correspond to the train set, test set, and (optionally) validation
set. In these cases, the output of `split_vertices` will be a `NamedTuple` with keys &quot;train&quot;, &quot;test&quot;, and
(optionally) &quot;val&quot; and values of `HGNNHypergraph`s; otherwise, the output is a vector of `HGNNHypergraph`s.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/split.jl#L715-L751">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.split_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.split_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.split_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_vertices(
    hg::HGNNDiHypergraph{T,D},
    masks::AbstractVector{BitVector}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

split_vertices(
    hg::HGNNDiHypergraph{T,D},
    train_mask::BitVector,
    test_mask::BitVector;
    val_mask::Union{BitVector, Nothing} = nothing,
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

split_vertices(
    hg::HGNNDiHypergraph{T,D},
    index_groups::AbstractVector{V}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}, V &lt;: AbstractVector{Int}}

split_vertices(
    hg::HGNNDiHypergraph{T,D},
    train_inds::AbstractVector{Int},
    test_inds::AbstractVector{Int};
    val_inds::Union{AbstractVector{Int}, Nothing} = nothing
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Split a single `HGNNDiHypergraph` into an arbitrary number of `HGNNDiHypergraph`s by partitioning vertices. This
will also partition hyperedges and hypergraphs. If no vertex in a particular partition is incident on a hyperedge,
then that hyperedge and its associated features will not be present in the resulting `HGNNDiHypergraph`. Similarly,
if no vertex in the partition belongs to a particular sub-hypergraph (based on `hypergraph_id`s), then that
hypergraph and its associated features will not be present in the resulting `HGNNDiHypergraph`.

Users can provide partitions as `BitVector` masks (length `V`, where `V` is the number of vertices) or vectors of
indices (which will be converted into masks). To facilitate train-val-test splits, users can specify which
mask/indices correspond to the train set, test set, and (optionally) validation set. In these cases, the output of
`split_vertices` will be a `NamedTuple` with keys &quot;train&quot;, &quot;test&quot;, and (optionally) &quot;val&quot; and values of
`HGNNDiHypergraph`s; otherwise, the output is a vector of `HGNNDiHypergraph`s.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/split.jl#L169-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.split_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.split_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{BitVector}}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.split_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_vertices(
    hg::HGNNHypergraph{T,D},
    masks::AbstractVector{BitVector}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

split_vertices(
    hg::HGNNHypergraph{T,D},
    train_mask::BitVector,
    test_mask::BitVector;
    val_mask::Union{BitVector, Nothing} = nothing,
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

split_vertices(
    hg::HGNNHypergraph{T,D},
    index_groups::AbstractVector{V}
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}, V &lt;: AbstractVector{Int}}

split_vertices(
    hg::HGNNHypergraph{T,D},
    train_inds::AbstractVector{Int},
    test_inds::AbstractVector{Int};
    val_inds::Union{AbstractVector{Int}, Nothing} = nothing
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Split a single `HGNNHypergraph` into an arbitrary number of `HGNNHypergraph`s by partitioning vertices. This will
also partition hyperedges and hypergraphs. If no vertex in a particular partition is incident on a hyperedge, then
that hyperedge and its associated features will not be present in the resulting `HGNNHypergraph`. Similarly, if no
vertex in the partition belongs to a particular sub-hypergraph (based on `hypergraph_id`s), then that hypergraph
and its associated features will not be present in the resulting `HGNNHypergraph`.

Users can provide partitions as `BitVector` masks (length `V`, where `V` is the number of vertices) or vectors of
indices (which will be converted into masks). To facilitate train-val-test splits, users can specify which
mask/indices correspond to the train set, test set, and (optionally) validation set. In these cases, the output
of `split_vertices` will be a `NamedTuple` with keys &quot;train&quot;, &quot;test&quot;, and (optionally) &quot;val&quot; and values of
`HGNNHypergraph`s; otherwise, the output is a vector of `HGNNHypergraph`s.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/split.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.uniform_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.uniform_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.uniform_negative_sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uniform_negative_sample(
    hg::HGNNDiHypergraph{T, D},
    n::Int,
    rng::AbstractRNG;
    max_trials::Int = 10
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Sample `n` negative hyperedges in a directed hypergraph `hg` using a random number generator `rng`
and a uniform sampling strategy.

It is possible that any given hyperedge generated using uniform sampling may be a duplicate or may not be a
negative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm
will attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still
possible that less than `n` unique negative hyperedges will be produced.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L841-L856">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.uniform_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#HyperGraphNeuralNetworks.uniform_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>HyperGraphNeuralNetworks.uniform_negative_sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uniform_negative_sample(
    hg::HGNNHypergraph{T, D},
    n::Int,
    rng::AbstractRNG;
    max_trials::Int = 10
) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Sample `n` negative hyperedges in an undirected hypergraph `hg` using a random number generator `rng`
and a uniform sampling strategy.

It is possible that any given hyperedge generated using uniform sampling may be a duplicate or may not be a
negative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm
will attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still
possible that less than `n` unique negative hyperedges will be produced.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L790-L805">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.vertex_degree_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph" href="#HyperGraphNeuralNetworks.vertex_degree_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph"><code>HyperGraphNeuralNetworks.vertex_degree_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertex_degree_matrix(hg::H) where {H &lt;: AbstractSimpleHypergraph}
vertex_degree_matrix(hg::H) where {H &lt;: AbstractDirectedHypergraph}

A `VxV` matrix (where `V` is the number of vertices in `hg`) where the diagonal element `(i,i)` is the degree of
vertex `i` and all other elements are 0. For directed hypergraphs, two degree matrices are provided: one with
diagonal elements equal to the number of hyperedges in which a given vertex is in the tail and the other with
diagonal elements equal to the number of hyperedges in which a given vertex is in the head.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L695-L703">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.vertex_weight_matrix-Tuple{H} where H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph" href="#HyperGraphNeuralNetworks.vertex_weight_matrix-Tuple{H} where H&lt;:SimpleDirectedHypergraphs.AbstractDirectedHypergraph"><code>HyperGraphNeuralNetworks.vertex_weight_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertex_weight_matrix(hg::H; weighting_function::Function=sum) where {H &lt;: AbstractDirectedHypergraph}

Return two NxN diagonal weight matrices for the directed hypergraph `hg`, where N is the number of vertices in
`hg`. One matrix is based on the hyperedge tails that each vertex is included in; the other is based on the
hyperedge heads that each vertex is included in. Because SimpleHypergraphs hypergraphs can have different weights
for each vertex-hyperedge pair, the weight of a vertex is ambiguous. The user can specify a `weighting_function`
(default is `sum`) that operates on each row of the hypergraph tail/head weighted incidence matrix.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L650-L658">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HyperGraphNeuralNetworks.vertex_weight_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph" href="#HyperGraphNeuralNetworks.vertex_weight_matrix-Tuple{H} where H&lt;:SimpleHypergraphs.AbstractSimpleHypergraph"><code>HyperGraphNeuralNetworks.vertex_weight_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertex_weight_matrix(hg::H; weighting_function::Function=sum) where {H &lt;: AbstractSimpleHypergraph}

Return an NxN diagonal weight matrix for the undirected hypergraph `hg`, where N is the number of vertices in `hg`.
Because SimpleHypergraphs hypergraphs can have different weights for each vertex-hyperedge pair, the weight of a
vertex is ambiguous. The user can specify a `weighting_function` (default is `sum`) that operates on each row of
the hypergraph weighted incidence matrix.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/query.jl#L614-L621">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleDirectedHypergraphs.to_undirected-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#SimpleDirectedHypergraphs.to_undirected-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>SimpleDirectedHypergraphs.to_undirected</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_undirected(hg::HGNNDiHypergraph{T,D}) where {T &lt;: Real, D &lt;: AbstractDict{Int, T}}

Converts a directed hypergraph into an undirected hypergraph.
Tail and head hyperedges are combined; that is, for all hyperedges he_orig in
the directed hypergraph h, all vertices in the head or tail are added to a
corresponding undirected hyperedge he_new in the undirected hypergraph h&#39;.

Vertex, hyperedge, and hypergraph features, as well as the hypergraph IDs, are undisturbed.

Because vertex-hyperedge weights are restricted to real numbers, we cannot
combine the weights, so we simply set the values to 1.0 if a given vertex
is in a given hyperedge</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/transform.jl#L295-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleHypergraphs.add_hyperedge!-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#SimpleHypergraphs.add_hyperedge!-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>SimpleHypergraphs.add_hyperedge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_hyperedge!(::HGNNDiHypergraph{T, D}; ::D = D()) where {T &lt;: Real, D &lt;: AbstractDict{Int,T}}

This function is not implemented for HGNNDiHypergraph.
    
The basic hypergraph structure of HGNNDiHypergraph (i.e., the number of vertices, the hyperedges, and the hypergraph
IDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore
objects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.

To create a new HGNNDiHypergraph object with an additional hyperedge, use `add_hyperedge`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L1328-L1339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleHypergraphs.add_hyperedge!-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#SimpleHypergraphs.add_hyperedge!-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>SimpleHypergraphs.add_hyperedge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_hyperedge!(::HGNNHypergraph{T, D}; ::D = D()) where {T &lt;: Real, D &lt;: AbstractDict{Int,T}}

This function is not implemented for HGNNHypergraph.
    
The basic hypergraph structure of HGNNHypergraph (i.e., the number of vertices, the hyperedges, and the hypergraph
IDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore
objects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.

To create a new HGNNHypergraph object with an additional hyperedge, use `add_hyperedge`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L466-L477">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleHypergraphs.add_vertex!-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#SimpleHypergraphs.add_vertex!-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>SimpleHypergraphs.add_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(::HGNNDiHypergraph{T, D}; ::D = D()) where {T &lt;: Real, D &lt;: AbstractDict{Int,T}}

This function is not implemented for HGNNDiHypergraph.
    
The basic hypergraph structure of HGNNDiHypergraph (i.e., the number of vertices, the hyperedges, and the
hypergraph IDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore
objects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.

To create a new HGNNDiHypergraph object with an additional vertex, use `add_vertex`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L1127-L1138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleHypergraphs.add_vertex!-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}" href="#SimpleHypergraphs.add_vertex!-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:AbstractDict{Int64, T}}"><code>SimpleHypergraphs.add_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_vertex!(::HGNNHypergraph{T, D}; ::D = D()) where {T &lt;: Real, D &lt;: AbstractDict{Int,T}}

This function is not implemented for HGNNHypergraph.
    
The basic hypergraph structure of HGNNHypergraph (i.e., the number of vertices, the hyperedges, and the hypergraph
IDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore
objects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.

To create a new HGNNHypergraph object with an additional vertex, use `add_vertex`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L251-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleHypergraphs.remove_hyperedge!-Tuple{HGNNDiHypergraph, Int64}" href="#SimpleHypergraphs.remove_hyperedge!-Tuple{HGNNDiHypergraph, Int64}"><code>SimpleHypergraphs.remove_hyperedge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_hyperedge!(::HGNNHypergraph, ::Int)

This function is not implemented for HGNNHypergraph.
    
The basic hypergraph structure of HGNNHypergraph (i.e., the number of vertices, the hyperedges, and the hypergraph
IDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore
objects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.

To create a new HGNNHypergraph object with a hyperedge removed, use `remove_hyperedge`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L1486-L1496">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleHypergraphs.remove_hyperedge!-Tuple{HGNNHypergraph, Int64}" href="#SimpleHypergraphs.remove_hyperedge!-Tuple{HGNNHypergraph, Int64}"><code>SimpleHypergraphs.remove_hyperedge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_hyperedge!(::HGNNHypergraph, ::Int)

This function is not implemented for HGNNHypergraph.
    
The basic hypergraph structure of HGNNHypergraph (i.e., the number of vertices, the hyperedges, and the hypergraph
IDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore
objects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.

To create a new HGNNHypergraph object with a hyperedge removed, use `remove_hyperedge`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L539-L549">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleHypergraphs.remove_vertex!-Tuple{HGNNDiHypergraph, Int64}" href="#SimpleHypergraphs.remove_vertex!-Tuple{HGNNDiHypergraph, Int64}"><code>SimpleHypergraphs.remove_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_vertex!(::HGNNDiHypergraph, ::Int)

This function is not implemented for HGNNDiHypergraph.
    
The basic hypergraph structure of HGNNDiHypergraph (i.e., the number of vertices, the hyperedges, and the hypergraph
IDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore
objects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.

To create a new HGNNDiHypergraph object with a vertex removed, use `remove_vertex`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L1232-L1243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimpleHypergraphs.remove_vertex!-Tuple{HGNNHypergraph, Int64}" href="#SimpleHypergraphs.remove_vertex!-Tuple{HGNNHypergraph, Int64}"><code>SimpleHypergraphs.remove_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_vertex!(::HGNNHypergraph, ::Int)

This function is not implemented for HGNNHypergraph.
    
The basic hypergraph structure of HGNNHypergraph (i.e., the number of vertices, the hyperedges, and the hypergraph
IDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore
objects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.

To create a new HGNNHypergraph object with a vertex removed, use `remove_vertex`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CoReACTER/HyperGraphNeuralNetworks.jl/blob/a963edab4b8175eff320c6a997ed9f211f435288/src/core/hypergraphs.jl#L392-L403">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 25 September 2025 08:31">Thursday 25 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
