var documenterSearchIndex = {"docs":
[{"location":"#HyperGraphNeuralNetworks","page":"Home","title":"HyperGraphNeuralNetworks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for HyperGraphNeuralNetworks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#HyperGraphNeuralNetworks.AbstractHGNNDiHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.AbstractHGNNDiHypergraph","text":"AbstractHGNNDiHypergraph{T} <: AbstractDirectedHypergraph{T}\n\nAn abstract directed hypergraph type for use in machine learning\n\n\n\n\n\n","category":"type"},{"location":"#HyperGraphNeuralNetworks.AbstractHGNNHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.AbstractHGNNHypergraph","text":"AbstractHGNNHypergraph{T} <: AbstractSimpleHypergraph{T}\n\nAn abstract undirected hypergraph type for use in machine learning\n\n\n\n\n\n","category":"type"},{"location":"#HyperGraphNeuralNetworks.AbstractNegativeSamplingStrategy","page":"Home","title":"HyperGraphNeuralNetworks.AbstractNegativeSamplingStrategy","text":"abstract type AbstractNegativeSamplingStrategy\nstruct UniformSample <: AbstractNegativeSamplingStrategy\nstruct SizedSample <: AbstractNegativeSamplingStrategy\nstruct MotifSample <: AbstractNegativeSamplingStrategy\nstruct CliqueSample <: AbstractNegativeSamplingStrategy\n\nTypes for negative sampling of hyperedges in hypergraphs (see `negative_sample_hyperedge`).\n\n\n\n\n\n","category":"type"},{"location":"#HyperGraphNeuralNetworks.HGNNHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.HGNNHypergraph","text":"HGNNHypergraph{T<:Real, D<:AbstractDict{Int,T}} <: AbstractHGNNHypergraph{Union{T, Nothing}}\n\nAn undirected hypergraph type for use in hypergraph neural networks\n\nConstructors\n\nHGNNHypergraph{T,D}(\n    h::AbstractSimpleHypergraph;\n    hypergraph_ids::Union{Nothing, AbstractVector{<:Integer}} = nothing,\n    vdata = nothing,\n    hedata = nothing,\n    hgdata = nothing\n) where {T<:Real, D<:AbstractDict{Int, T}}\n\nHGNNHypergraph{T}(\n    h::AbstractSimpleHypergraph;\n    hypergraph_ids::Union{Nothing, AbstractVector{<:Integer}} = nothing,\n    vdata::Union{DataStore, Nothing} = nothing,\n    hedata::Union{DataStore, Nothing} = nothing,\n    hgdata::Union{DataStore, Nothing} = nothing\n) where {T<:Real}\n\nHGNNHypergraph(\n    h::AbstractSimpleHypergraph;\n    hypergraph_ids::Union{Nothing, AbstractVector{<:Integer}} = nothing,\n    vdata = nothing,\n    hedata = nothing,\n    hgdata = nothing\n)\n\nConstruct an `HGNNHypergraph` from a previously constructed hypergraph. Optionally, the user can specify\nwhat hypergraph each vertex belongs to (if multiple distinct hypergraphs are included), as well as vertex,\nhyperedge, and hypergraph features.\n\nHGNNHypergraph{T,D}(\n    incidence::Matrix{Union{T, Nothing}};\n    hypergraph_ids::Union{Nothing, AbstractVector{<:Integer}} = nothing,\n    vdata = nothing,\n    hedata = nothing,\n    hgdata = nothing\n) where {T<:Real, D<:AbstractDict{Int, T}}\n\nHGNNHypergraph{T}(\n    incidence::Matrix{Union{T, Nothing}};\n    hypergraph_ids::Union{Nothing, AbstractVector{<:Integer}} = nothing,\n    vdata = nothing,\n    hedata = nothing,\n    hgdata = nothing\n) where {T<:Real}\n\nHGNNHypergraph(\n    incidence::Matrix{Union{T, Nothing}};\n    hypergraph_ids::Union{Nothing, AbstractVector{<:Integer}} = nothing,\n    vdata = nothing,\n    hedata = nothing,\n    hgdata = nothing\n) where {T<:Real}\n\nConstruct an `HGNNHypergraph` from an incidence matrix. The incidence matrix is an `M`x`N` matrix, where `M` is the\nnumber of vertices and `N` is the number of hyperedges.\n\nfunction HGNNHypergraph(num_nodes::T; vdata=nothing, kws...) where {T<:Integer}\n\nConstruct an `HGNNHypergraph` with no hyperedges and `num_nodes` vertices.\n\nfunction HGNNHypergraph(; num_nodes=nothing, vdata=nothing, kws...)\n\nConstruct an `HGNNHypergraph` with minimal (perhaps no) information.\n\nArguments\n\n* `T` : type of weight values stored in the hypergraph's incidence matrix\n* `D` : dictionary type for storing values; the default is `Dict{Int, T}`\n* `hypergraph_ids` : Nothing (implying that all vertices belong to the same hypergraph) or a vector of ID integers\n* `vdata` : an optional DataStore (from GNNGraphs.jl) containing vertex-level features. Each entry in `vdata`\n    should have `M` entries/observations, where `M` is the number of vertices in the hypergraph\n* `hedata` : an optional DataStore containing hyperedge-level features. Each entry in `hedata` should have `N`\n    entries/observations, where `N` is the number of hyperedges in the hypergraph\n* `hgdata` : an optional DataStore containing hypergraph-level features. Each entry in `hgdata` should have `G`\n    entries/observations, where `G` is the number of hypergraphs in the HGNNHypergraph (note: the maximum index\n    in `hypergraph_ids` should be `G`)\n* `incidence` : a matrix representation; rows are vertices and columns are hyperedges\n* `num_nodes` : the number of vertices in the hypergraph (i.e., `M`)\n\n\n\n\n\n","category":"type"},{"location":"#Base.copy-Tuple{HGNNDiHypergraph}","page":"Home","title":"Base.copy","text":"copy(hg::HGNNDiHypergraph; deep=false)\n\nCreate a copy of hg. If deep is true, then copy will be a deep copy (equivalent to deepcopy(hg)), otherwise it will be a shallow copy with the same underlying hypergraph data.\n\n\n\n\n\n","category":"method"},{"location":"#Base.copy-Tuple{HGNNHypergraph}","page":"Home","title":"Base.copy","text":"copy(hg::HGNNHypergraph; deep=false)\n\nCreate a copy of `hg`. If `deep` is `true`, then copy will be a deep copy (equivalent to `deepcopy(hg)`),\ntherwise it will be a shallow copy with the same underlying hypergraph data.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.LinAlg.incidence_matrix-Tuple{H} where H<:SimpleDirectedHypergraphs.AbstractDirectedHypergraph","page":"Home","title":"Graphs.LinAlg.incidence_matrix","text":"incidence_matrix(hg::H) where {H <: AbstractDirectedHypergraph}\n\nConvert the matrix representation of an undirected hypergraph `hg` into two incidence matrices, `Mt` (the tail\nincidence matrix) and `Mh` (the head incidence matrix). The (i,j)-th element of `Mt` is 1 if vertex `i` is in the\ntail of hyperedge `j` and 0 otherwise. Likewise, `Mh`[i, j] is 1 if `i` is in the head of `j` and 0 otherwise\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.LinAlg.incidence_matrix-Tuple{H} where H<:SimpleHypergraphs.AbstractSimpleHypergraph","page":"Home","title":"Graphs.LinAlg.incidence_matrix","text":"incidence_matrix(hg::H) where {H <: AbstractSimpleHypergraph}\n\nConvert the matrix representation of an undirected hypergraph `hg` to an incidence matrix. The (i,j)-th element of\nthe incidence matrix `M` is 1 if vertex `i` is in hyperedge `j` and 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.all_neighbors-Tuple{H} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"Graphs.all_neighbors","text":"all_neighbors(hg::H; same_side::Bool=false) where {H <: AbstractHGNNDiHypergraph}\n\nReturns all neighbors for all vertices in a directed hypergraph. The set of all neighbors for a vertex is the union\nof the set of all incoming neighbors and outgoing neighbors. Note that the definition of `incoming` and `outgoing`\nneighbor depends on if `same_side` is true or false; see below.\n\nArgs:\n    hg::H where {H <: AbstractHGNNDiHypergraph} : Hypergraph\n    same_side::Bool : If true, return the neighbors within the same side of a hyperedge; i.e., if vertex\n    `i` and vertex `j` are both in the tail of hyperedge `e`, they are neighbors. If false, instead return\n    the neighbors on the opposite side of the hyperedge; i.e., if vertex `i` is in the tail of `e` and vertex\n    `j` is in the head of `e`, then `i` and `j` are neighbors. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.all_neighbors-Tuple{H} where H<:AbstractHGNNHypergraph","page":"Home","title":"Graphs.all_neighbors","text":"all_neighbors(hg::H) where {H <: AbstractHGNNHypergraph}\n\nCollect all neighbors for all vertices in an undirected hypergraph.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.all_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"Graphs.all_neighbors","text":"all_neighbors(hg::H, i::Int; same_side::Bool=false) where {H <: AbstractHGNNDiHypergraph}\n\nReturns the neighbors for vertex `i` in a directed hypergraph `hg`. The set of all neighbors for a vertex is the\nunion of the set of all incoming neighbors and outgoing neighbors. Note that the definition of `incoming` and\n`outgoing` neighbor depends on if `same_side` is true or false; see below.\n\nArgs:\n    hg::H where {H <: AbstractHGNNDiHypergraph} : Hypergraph\n    i::Int : Vertex index\n    same_side::Bool : If true, return the neighbors within the same side of a hyperedge; i.e., if vertex\n    `i` and vertex `j` are both in the tail of hyperedge `e`, they are neighbors. If false, instead return\n    the neighbors on the opposite side of the hyperedge; i.e., if vertex `i` is in the tail of `e` and vertex\n    `j` is in the head of `e`, then `i` and `j` are neighbors. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.all_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H<:AbstractHGNNHypergraph","page":"Home","title":"Graphs.all_neighbors","text":"all_neighbors(hg::H, i::Int) where {H <: AbstractHGNNHypergraph}\n\nReturns the neighbors of vertex `i` in undirected hypergraph `hg`.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.degree-Tuple{H} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"Graphs.degree","text":"degree(hg::H) where {H <: AbstractHGNNDiHypergraph}\ndegree(hg::H, i::Int) where {H <: AbstractHGNNDiHypergraph}\ndegree(hg::H, inds::AbstractVector{Int}) where {H <: AbstractHGNNDiHypergraph}\n\nReturn the degree of all vertices (if no index is provided) or of a specific group of indices\nFor directed hypergraphs, the total degree is the sum of the incoming degree (see `indegree`) and the\noutgoing degree (see `outdegree`).\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.degree-Tuple{H} where H<:AbstractHGNNHypergraph","page":"Home","title":"Graphs.degree","text":"degree(hg::H) where {H <: AbstractHGNNHypergraph}\ndegree(hg::H, i::Int) where {H <: AbstractHGNNHypergraph}\ndegree(hg::H, inds::AbstractVector{Int}) where {H <: AbstractHGNNHypergraph}\n\nReturn the degree of all vertices (if no index is provided) or of a specific group of vertices.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.has_self_loops-Tuple{H} where H<:AbstractHGNNHypergraph","page":"Home","title":"Graphs.has_self_loops","text":"has_self_loops(_::H) where {H <: AbstractHGNNHypergraph}\nhas_self_loops(hg::H) where {H <: AbstractHGNNDiHypergraph}\n\nDoes the hypergraph contain self-loops? For an undirected hypergraph, this is defined to always be `false`. For a\ndirected hypergraph, this function checks the intersection between the tail and the head of each hyperedge in `hg`.\nIf any intersections are nonempty, then the dihypergraph has a self-loop.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.indegree-Tuple{H} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"Graphs.indegree","text":"indegree(hg::H) where {H <: AbstractHGNNDiHypergraph}\nindegree(hg::H, i::Int) where {H <: AbstractHGNNDiHypergraph}\nindegree(hg::H, inds::AbstractVector{Int}) where {H <: AbstractHGNNDiHypergraph}\n\nReturn the incoming degree of all vertices (if no index is provided) or of a specific group of indices for a\ndirected hypergraph. The incoming degree is the number of directed hyperedges containing a vertex in the head.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.inneighbors-Tuple{H} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"Graphs.inneighbors","text":"inneighbors(hg::H; same_side::Bool=false) where {H <: AbstractHGNNDiHypergraph}\n\nReturn the incoming neighbors for a directed hypergraph `hg`. Note that the definition of `incoming` depends on\nif `same_side` is true or false; see below.\n\nArgs:\n    hg::H where {H <: AbstractHGNNDiHypergraph} : Hypergraph\n    same_side::Bool : If true, return the neighbors that share a hyperedge head with each vertex; i.e., if vertex\n    `i` and vertex `j` are both in the head of some hyperedge `e`, they are incoming neighbors. If false, instead\n    return the neighbors on the opposite side of the hyperedge; i.e., if vertex `i` is in the head of `e` and vertex\n    `j` is in the tail of `e`, then `j` is an incoming neighbor to `i`. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.inneighbors-Union{Tuple{H}, Tuple{H, Int64}} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"Graphs.inneighbors","text":"inneighbors(hg::H, i::Int; same_side::Bool=false) where {H <: AbstractHGNNDiHypergraph}\n\nReturn the incoming neighbors for a vertex `i` of a directed hypergraph `hg`. Note that the definition of\n`incoming` depends on if `same_side` is true or false; see below.\n\nArgs:\n    hg::H where {H <: AbstractHGNNDiHypergraph} : Hypergraph\n    i::Int : Vertex index\n    same_side::Bool : If true, return the neighbors that share a hyperedge head with each vertex; i.e., if vertex\n    `i` and vertex `j` are both in the head of some hyperedge `e`, they are incoming neighbors. If false, instead\n    return the neighbors on the opposite side of the hyperedge; i.e., if vertex `i` is in the head of `e` and vertex\n    `j` is in the tail of `e`, then `j` is an incoming neighbor to `i`. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.outdegree-Tuple{H} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"Graphs.outdegree","text":"outdegree(hg::H) where {H <: AbstractHGNNDiHypergraph}\noutdegree(hg::H, i::Int) where {H <: AbstractHGNNDiHypergraph}\noutdegree(hg::H, inds::AbstractVector{Int}) where {H <: AbstractHGNNDiHypergraph}\n\nReturn the outgoing degree of all vertices (if no index is provided) or of a specific group of indices for a\ndirected hypergraph. The outgoing degree is the number of directed hyperedges containing a vertex in the tail.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.outneighbors-Tuple{H} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"Graphs.outneighbors","text":"outneighbors(hg::H; same_side::Bool=false) where {H <: AbstractHGNNDiHypergraph}\n\nReturn the outgoing neighbors for a directed hypergraph `hg`. Note that the definition of `outgoing` depends on\nif `same_side` is true or false; see below.\n\nArgs:\n    hg::H where {H <: AbstractHGNNDiHypergraph} : Hypergraph\n    same_side::Bool : If true, return the neighbors that share a hyperedge tail with each vertex; i.e., if vertex\n    `i` and vertex `j` are both in the tail of some hyperedge `e`, they are outgoing neighbors. If false, instead\n    return the neighbors on the opposite side of the hyperedge; i.e., if vertex `i` is in the tail of `e` and vertex\n    `j` is in the head of `e`, then `j` is an outgoing neighbor to `i`. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"#Graphs.outneighbors-Union{Tuple{H}, Tuple{H, Int64}} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"Graphs.outneighbors","text":"outneighbors(hg::H, i::Int; same_side::Bool=false) where {H <: AbstractHGNNDiHypergraph}\n\nReturn the outgoing neighbors for a vertex `i` of a directed hypergraph `hg`. Note that the definition of\n`outgoing` depends on if `same_side` is true or false; see below.\n\nArgs:\n    hg::H where {H <: AbstractHGNNDiHypergraph} : Hypergraph\n    i::Int : Vertex index\n    same_side::Bool : If true, return the neighbors that share a hyperedge tail with each vertex; i.e., if vertex\n    `i` and vertex `j` are both in the tail of some hyperedge `e`, they are outgoing neighbors. If false, instead\n    return the neighbors on the opposite side of the hyperedge; i.e., if vertex `i` is in the tail of `e` and vertex\n    `j` is in the head of `e`, then `j` is an outgoing neighbor to `i`. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.add_hyperedge-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, GNNGraphs.DataStore}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.add_hyperedge","text":"add_hyperedge(\n    hg::HGNNDiHypergraph{T, D},\n    features::DataStore;\n    vertices_tail::D = D(),\n    vertices_head::D = D(),\n) where {T <: Real, D <: AbstractDict{Int,T}}\n\nAdds a hyperedge to a given `HGNNDiHypergraph`. Because `HGNNDiHypergraph` is immutable, this creates a new\n`HGNNDiHypergraph`. Optionally, existing vertices can be added to the tail and/or head of the hyperedge. The\nparamaters `vertices_tail` and `vertices_head` represent dictionaries of vertex identifiers and values stored at\nthe tail and head of hyperedges, respectively. Note that the `features` DataStore is not optional; however, if `hg`\nhas no `hedata` (i.e., if `hedata` is nothing), this can be empty.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.add_hyperedge-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, GNNGraphs.DataStore}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.add_hyperedge","text":"add_hyperedge(\n    hg::HGNNHypergraph{T, D},\n    features::DataStore;\n    vertices::D = D(),\n) where {T <: Real, D <: AbstractDict{Int,T}}\n\nAdds a hyperedge to a given `HGNNHypergraph`. Because `HGNNHypergraph` is immutable, this creates a new\n`HGNNHypergraph`. Optionally, existing vertices can be added to the created hyperedge. The paramater `vertices`\nrepresents a dictionary of vertex identifiers andvalues stored at the hyperedges. Note that the `features`\nDataStore is not optional; however, if `hg` has no `hedata` (i.e., if `hedata` is nothing), this can be empty.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.add_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.add_hyperedges","text":"add_hyperedges(\n    hg::HGNNDiHypergraph{T, D},\n    n::Int,\n    features::DataStore;\n    vertices_tail::AbstractVector{D} = Vector{D}(D(), n),\n    vertices_head::AbstractVector{D} = Vector{D}(D(), n)\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nAdds a set of hyperedges to a directed hypergraph `hg`. Optionally, the user can specify the vertices that are\nincident on these hyperedges.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.add_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.add_hyperedges","text":"add_hyperedges(\n    hg::HGNNHypergraph{T, D},\n    n::Int,\n    features::DataStore;\n    vertices::AbstractVector{D} = Vector{D}(D(), n)    \n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nAdds a set of hyperedges to an undirected hypergraph `hg`. Optionally, the user can specify the vertices that are\nincident on these hyperedges.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.add_self_loops-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.add_self_loops","text":"add_self_loops(\n    hg::HGNNDiHypergraph{T, D};\n    add_repeated_hyperedge::Bool = false\n) where {T<:Real, D<:AbstractDict{Int,T}}\n\nAdd self-loops (hyperedges with the tail and the head both containing only a single vertex `v`) to a directed\nhypergraph. If `add_repeated_hyperedge` is true (default is false), then new self-loops will be added, even when\na self-loop already exists for some vertex.\n\nNOTE: this function will throw an AssertionError if hg.hedata is not empty\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.add_self_loops-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.add_self_loops","text":"add_self_loops(\n    hg::HGNNHypergraph{T, D};\n    add_repeated_hyperedge::Bool = false\n) where {T<:Real, D<:AbstractDict{Int,T}}\n\nAdd self-loops (hyperedges containing a single vertex) to an undirected hypergraph. If `add_repeated_hyperedge` is\ntrue (default is false), then new self-loops will be added, even when a self-loop already exists for some vertex.\n\nNOTE: this function will throw an AssertionError if hg.hedata is not empty\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.add_vertex-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, GNNGraphs.DataStore}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.add_vertex","text":"add_vertex(\n    hg::HGNNDiHypergraph{T, D},\n    features::DataStore;\n    hyperedges_tail::D = D(),\n    hyperedges_head::D = D(),\n    hypergraph_id::Int = 1\n) where {T <: Real, D <: AbstractDict{Int,T}}\n\nCreate a new HGNNDiHypergraph that adds a vertex to an existing directed hypergraph `hg`. Note that the `features`\nDataStore is not optional, but if the input hypergraph has no vertex data, this can be empty. Optionally, the\nvertex can be added to existing hyperedges. The `hyperedges_tail` and `hyperedges_head` parameters include\ndictionaries of hyperedge identifiers and values stored at the hyperedges.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.add_vertex-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, GNNGraphs.DataStore}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.add_vertex","text":"add_vertex(\n    hg::HGNNHypergraph{T, D},\n    features::DataStore;\n    hyperedges::D = D(),\n    hypergraph_id::Int = 1\n) where {T <: Real, D <: AbstractDict{Int,T}}\n\nCreate a new HGNNHypergraph that adds a vertex to an existing hypergraph `hg`. Note that the `features` DataStore\nis not optional, but if the input hypergraph has no vertex data, this can be empty. Optionally, the vertex can be\nadded to existing hyperedges. The `hyperedges` parameter presents a dictionary of hyperedge identifiers and values\nstored at the hyperedges.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.add_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.add_vertices","text":"add_vertices(\n    hg::HGNNDiHypergraph{T, D},\n    n::Int,\n    features::DataStore;\n    hyperedges_tail::AbstractVector{D} = Vector{D}(D(), n),\n    hyperedges_head::AbstractVector{D} = Vector{D}(D(), n),\n    hypergraph_ids::AbstractVector{Int} = ones(Int, n)\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nAdds a set of vertices to an directed hypergraph `hg`. Optionally, the user can specify the hyperedges on which\nthese vertices are incident.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.add_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, GNNGraphs.DataStore}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.add_vertices","text":"add_vertices(\n    hg::HGNNHypergraph{T, D},\n    n::Int,\n    features::DataStore;\n    hyperedges::AbstractVector{D} = Vector{D}(D(), n),\n    hypergraph_ids::AbstractVector{Int} = ones(Int, n)\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nAdds a set of vertices to an undirected hypergraph `hg`. Optionally, the user can specify the hyperedges on which\nthese vertices are incident.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.check_num_hyperedges-Union{Tuple{H}, Tuple{H, AbstractArray}} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.check_num_hyperedges","text":"check_num_hyperedges(hg::H, x::AbstractArray) where {H <: AbstractHGNNDiHypergraph}\ncheck_num_hyperedges(hg::H, x::Union{Tuple, NamedTuple}) where {H <: AbstractHGNNDiHypergraph}\n\nEnsure that an array abstract array, tuple, or named tuple (i.e., tensor) `x` has the appropriate final dimension,\nequal to the number of hyperedges in the associated directed hypergraph `hg`\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.check_num_hyperedges-Union{Tuple{H}, Tuple{H, AbstractArray}} where H<:AbstractHGNNHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.check_num_hyperedges","text":"check_num_hyperedges(hg::H, x::AbstractArray) where {H <: AbstractHGNNHypergraph}\ncheck_num_hyperedges(hg::H, x::Union{Tuple, NamedTuple}) where {H <: AbstractHGNNHypergraph}\n\nEnsure that an array abstract array, tuple, or named tuple (i.e., tensor) `x` has the appropriate final dimension,\nequal to the number of hyperedges in the associated hypergraph `hg`\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.check_num_vertices-Union{Tuple{H}, Tuple{H, AbstractArray}} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.check_num_vertices","text":"check_num_vertices(hg::H, x::AbstractArray) where {H <: AbstractHGNNDiHypergraph}\ncheck_num_vertices(hg::H, x::Union{Tuple, NamedTuple}) where {H <: AbstractHGNNDiHypergraph}\n\nEnsure that an array abstract array, tuple, or named tuple (i.e., tensor) `x` has the appropriate final dimension,\nequal to the number of vertices in the associated directed hypergraph `hg`\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.check_num_vertices-Union{Tuple{H}, Tuple{H, AbstractArray}} where H<:AbstractHGNNHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.check_num_vertices","text":"check_num_vertices(hg::H, x::AbstractArray) where {H <: AbstractHGNNHypergraph}\ncheck_num_vertices(hg::H, x::Union{Tuple, NamedTuple}) where {H <: AbstractHGNNHypergraph}\n\nEnsure that an array abstract array, tuple, or named tuple (i.e., tensor) `x` has the appropriate final dimension,\nequal to the number of vertices in the associated hypergraph `hg`\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.clique_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.clique_negative_sample","text":"clique_negative_sample(\n    hg::HGNNHypergraph{T, D},\n    n::Int,\n    rng::AbstractRNG;\n    max_trials::Int = 10\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nSample `n` negative hyperedges in an undirected hypergraph `hg` using a random number generator `rng` using the\n\"clique negative sampling\" (CNS) strategy described in Patil et al., \"Negative Sampling for Hyperlink Prediction in\nNetworks\", DOI: 10.1007/978-3-030-47436-2_46 (2020). CNS samples negative hyperedges using the clique-expanded\ngraph of `hg`, ensuring that the edge density of sampled hyperedges will always be 1. \n\nIt is possible that any given hyperedge generated using clique negative sampling may be a duplicate or may not be a\nnegative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm\nwill attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still\npossible that less than `n` unique negative hyperedges will be produced.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.combine_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, HGNNDiHypergraph{T, D}}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.combine_hypergraphs","text":"combine_hypergraphs(\n    hg1::HGNNDiHypergraph{T, D},\n    hg2::HGNNDiHypergraph{T, D}\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\ncombine_hypergraphs(\n    hg1::HGNNDiHypergraph{T,D},\n    hgothers::HGNNDiHypergraph{T,D}...\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\ncombine_hypergraphs(\n    hgs::AbstractVector{HGNNDiHypergraph{T,D}}\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nMerge two (or more) directed hypergraphs into a single hypergraph. This is used for batching (`MLUtils.batch`).\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.combine_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, HGNNHypergraph{T, D}}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.combine_hypergraphs","text":"combine_hypergraphs(\n    hg1::HGNNHypergraph{T, D},\n    hg2::HGNNHypergraph{T, D}\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\ncombine_hypergraphs(\n    hg1::HGNNHypergraph{T,D},\n    hgothers::HGNNHypergraph{T,D}...\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\ncombine_hypergraphs(\n    hgs::AbstractVector{HGNNHypergraph{T,D}}\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nMerge two (or more) undirected hypergraphs into a single hypergraph. This is used for batching (`MLUtils.batch`).\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.complex_incidence_matrix-Tuple{H} where H<:SimpleDirectedHypergraphs.AbstractDirectedHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.complex_incidence_matrix","text":"complex_incidence_matrix(hg::H) where {H <: AbstractDirectedHypergraph}\n\nConvert the matrix representation of an undirected hypergraph `hg` into a single complex-valued incidence matrix\n`M`. The (i,j)-th element of `M` is 1 if vertex `i` is in the head of hyperedge `j`, -im if `i` is in the tail of\n`j`, and 0 otherwise. If there are any hyperedges where any vertex is in both the tail and the head, an error is\nthrown.\n\nReference:\n    Fiorini, S., Coniglio, S., Ciavotta, M., Del Bue, A., Let There be Direction in Hypergraph Neural Networks.\n    Transactions on Machine Learning Research, 2024.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.erdos_renyi_hypergraph-Union{Tuple{H}, Tuple{Int64, Int64, Type{H}}} where H<:AbstractHGNNHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.erdos_renyi_hypergraph","text":"erdos_renyi_hypergraph(\n    nVertices::Int,\n    nEdges::Int,\n    HType::Type{H};\n    seed::Int = -1,\n    kws...\n) where {H <: AbstractHGNNHypergraph}\n\nerdos_renyi_hypergraph(\n    nVertices::Int,\n    nEdges::Int,\n    HType::Type{H};\n    seed::Int = -1,\n    no_self_loops::Bool = false,\n    kws...\n) where {H <: AbstractHGNNDiHypergraph}\n\nGenerate a *random* hypergraph (in the style of Erdős–Rényi random graphs) without any structural\nconstraints. See `SimpleHypergraphs.random_model`. The user can optionally seed the random number\ngenerator with kwarg `seed`. The default value is -1; if the value is greater than or equal to 0, then `seed` will\nbe used.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.get_hyperedge_weight-Union{Tuple{H}, Tuple{H, Int64}} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.get_hyperedge_weight","text":"get_hyperedge_weight(hg::H, he_ind::Int; side::Symbol = :both) where {H <: AbstractHGNNDiHypergraph}\nget_hyperedge_weight(hg::H, he_ind::Int, op::Function; side::Symbol = :both) where {H <: AbstractHGNNDiHypergraph}\n\nObtain the non-`nothing` weights associated with a directed hyperedge in `hg` given by index `he_ind`. See\n`get_hyperedge_weights` for more detail.\n\nTODO: add check for array bounds\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.get_hyperedge_weight-Union{Tuple{H}, Tuple{H, Int64}} where H<:AbstractHGNNHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.get_hyperedge_weight","text":"get_hyperedge_weight(hg::H, he_ind::Int) where {H <: AbstractHGNNHypergraph}\nget_hyperedge_weight(hg::H, he_ind::Int, op::Function) where {H <: AbstractHGNNHypergraph}\n\nObtain the non-`nothing` weights associated with a hyperedge in `hg` given by index `he_ind`. See\n`get_hyperedge_weights` for more detail\n\nTODO: add check for array bounds\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.get_hyperedge_weights-Tuple{H} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.get_hyperedge_weights","text":"get_hyperedge_weights(hg::H; side::Symbol = :both) where {H <: AbstractHGNNDiHypergraph}\nget_hyperedge_weights(hg::H, op::Function; side::Symbol = :both) where {H <: AbstractHGNNDiHypergraph}\n\nReturn the weights of a directed hypergraph `hg`. The user can choose to obtain the weights of the hyperedge tails\n(`side=:tail`), the heads (`side=:head`), or both (`side=:both`). The tail weights and head weights are both\nvectors of vectors, where the `i`th element of one such vector corresponds to the non-`nothing` weights of the tail\nor head of the `i`th hyperedge. If function `op` is provided, then the weights are transformed using `op` before\nbeing returned. Note that `op` should take only one argument.\n\nTODO: how to handle case where user wants a single weight value per hyperedge, using :both?\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.get_hyperedge_weights-Tuple{H} where H<:AbstractHGNNHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.get_hyperedge_weights","text":"get_hyperedge_weights(hg::H) where {H <: AbstractHGNNHypergraph}\nget_hyperedge_weights(hg::H, op::Function) where {H <: AbstractHGNNHypergraph}\n\nGet the weights of each hyperedge in the hypergraph `hg`. This function returns a vector of vectors, where each\nelement contains the non-`nothing` weights of the associated hyperedge. If the function `op` is provided, then\nthe weights are transformed using `op` before being returned. Note that `op` should take only one argument.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.get_hypergraph-Tuple{HGNNDiHypergraph, Int64}","page":"Home","title":"HyperGraphNeuralNetworks.get_hypergraph","text":"get_hypergraph(hg::HGNNDiHypergraph, i::Int; kws...)\n\nget_hypergraph(hg::HGNNDiHypergraph, i::AbstractVector{Int}; map_vertices::Bool = false)\n\nExtract one or more hypergraphs (based on `hypergraph_ids`) from an `HGNNHypergraph` containing multiple\nhypergraphs. This is used for unbatching (`MLUtils.unbatch`).\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.get_hypergraph-Tuple{HGNNHypergraph, Int64}","page":"Home","title":"HyperGraphNeuralNetworks.get_hypergraph","text":"get_hypergraph(hg::HGNNHypergraph, i::Int; kws...)\n\nget_hypergraph(hg::HGNNHypergraph, i::AbstractVector{Int}; map_vertices::Bool = false)\n\nExtract one or more hypergraphs (based on `hypergraph_ids`) from an `HGNNHypergraph` containing multiple\nhypergraphs. This is used for unbatching (`MLUtils.unbatch`).\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.has_multi_hyperedges-Tuple{H} where H<:AbstractHGNNHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.has_multi_hyperedges","text":"has_multi_hyperedges(hg::H) where {H <: AbstractHGNNHypergraph}\nhas_multi_hyperedges(hg::H) where {H <: AbstractHGNNDiHypergraph}\n\nChecks if there are any hyperedges with multiplicity greater than 1, i.e., if there are two or more hyperedges\ncontaining identical vertices. For directed hyperedges, both the tail vertices and the head vertices have to be\nidentical to be considered duplicates.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.hyperedge_degree_matrix-Tuple{H} where H<:SimpleHypergraphs.AbstractSimpleHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.hyperedge_degree_matrix","text":"hyperedge_degree_matrix(hg::H) where {H <: AbstractSimpleHypergraph}\nhyperedge_degree_matrix(hg::H) where {H <: AbstractDirectedHypergraph}\n\nAn `ExE` matrix (where `E` is the number of hyperedges in `hg`) where the diagonal element `(i,i)` is the degree of\nhyperedge `i` and all other elements are 0. For directed hypergraphs, two degree matrices are provided: one with\ndiagonal elements equal to the number of vertices in the tail of each hyperedge and the other with diagonal\nelements equal to the number of vertices in the head of each hyperedge.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.hyperedge_index-Tuple{H} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.hyperedge_index","text":"hyperedge_index(hg::H) where {H <: AbstractHGNNHypergraph}\n\nObtain the hyperedge index of a directed hypergraph `hg`. The index is returned as two vectors of vectors, one for\nthe hyperedge tails and the other for the hyperedge heads. The `i`th element of `ind_tail` contains the indices of\nthe vertices present in the tail of hyperedge `i`, and likewise, the `i`th element of `ind_head` contains the\nindices of the vertices in the head of hyperedge `i`.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.hyperedge_index-Tuple{H} where H<:AbstractHGNNHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.hyperedge_index","text":"hyperedge_index(hg::H) where {H <: AbstractHGNNHypergraph}\n\nObtain the hyperedge index of an undirected hypergraph `hg`. The index is a vector of vectors, where the `i`th\nelement of the index contains the indices of all vertices present in hyperedge `i`.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.hyperedge_neighbors-Tuple{H} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.hyperedge_neighbors","text":"hyperedge_neighbors(hg::H; directed::Bool=false) where {H <: AbstractHGNNDiHypergraph}\n\nReturns the neighbors of each hyperedge in directed hypergraph `hg`. If `directed` is true (default false), then\nhyperedge `i` is neighbors with hyperedge `j` if and only if there is at least one vertex in the head of `i` that\nis also in the tail of `j`. Otherwise, two hyperedges are neighbors if they share any vertices, irrespective of\nwhether those vertices are in the hyperedges' heads or tails.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.hyperedge_neighbors-Tuple{H} where H<:AbstractHGNNHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.hyperedge_neighbors","text":"hyperedge_neighbors(hg::H) where {H <: AbstractHGNNHypergraph}\n\nReturns the neighbors of each hyperedge in an undirected hypergraph `hg`. A hyperedge `e` is neighbors with a\nhyperedge `f` if there is at least one vertex contained in both `e` and `f`.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.hyperedge_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H<:AbstractHGNNDiHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.hyperedge_neighbors","text":"hyperedge_neighbors(hg::H, i::Int; directed::Bool=false) where {H <: AbstractHGNNDiHypergraph}\n\nReturns the neighbors of hyperedge `i` in directed hypergraph `hg`. If `directed` is true (default false), then\nhyperedge `i` is neighbors with hyperedge `j` if and only if there is at least one vertex in the head of `i` that\nis also in the tail of `j`. Otherwise, two hyperedges are neighbors if they share any vertices, irrespective of\nwhether those vertices are in the hyperedges' heads or tails.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.hyperedge_neighbors-Union{Tuple{H}, Tuple{H, Int64}} where H<:AbstractHGNNHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.hyperedge_neighbors","text":"hyperedge_neighbors(hg::H, i::Int) where {H <: AbstractHGNNHypergraph}\n\nReturns the neighbors of hyperedge `i` in an undirected hypergraph `hg`. A hyperedge `i` is neighbors with a\nhyperedge `e` if there is at least one vertex contained in both `i` and `e`.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.hyperedge_weight_matrix-Tuple{H} where H<:SimpleDirectedHypergraphs.AbstractDirectedHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.hyperedge_weight_matrix","text":"hyperedge_weight_matrix(h::H; weighting_function::Function=sum) where {H <: AbstractDirectedHypergraph}\n\nReturn two NxN diagonal weight matrices for the directed hypergraph `hg`, where N is the number of hyperedges in\n`hg`. One matrix is based on the hyperedge tails, and the other is based on the hyperedge heads. Because\nSimpleHypergraphs hypergraphs can have different weights for each vertex-hyperedge pair, the weight of a hyperedge\nis ambiguous. The user can specify a `weighting_function` (default is `sum`) that operates on each row of the\nhypergraph tail/head weighted incidence matrix.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.hyperedge_weight_matrix-Tuple{H} where H<:SimpleHypergraphs.AbstractSimpleHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.hyperedge_weight_matrix","text":"hyperedge_weight_matrix(hg::H; weighting_function::Function=sum) where {H <: AbstractSimpleHypergraph}\n\nReturn an NxN diagonal weight matrix for the undirected hypergraph `hg`, where N is the number of hyperedges in\n`hg`. Because SimpleHypergraphs hypergraphs can have different weights for each vertex-hyperedge pair, the weight\nof a hyperedge is ambiguous. The user can specify a `weighting_function` (default is `sum`) that operates on each\ncolumn of the hypergraph weighted incidence matrix.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.hypergraph_ids-Tuple{H} where H<:AbstractHGNNHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.hypergraph_ids","text":"hypergraph_ids(hg::H) where {H <: AbstractHGNNHypergraph}\nhypergraph_ids(hg::H) where {H <: AbstractHGNNDiHypergraph}\n\nReturns a vector containing the graph membership of each vertex in the hypergraph `hg`.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.motif_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.motif_negative_sample","text":"motif_negative_sample(\n    hg::HGNNHypergraph{T, D},\n    n::Int,\n    rng::AbstractRNG;\n    max_trials::Int = 10\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nSample `n` negative hyperedges in a directed hypergraph `hg` using a random number generator `rng` using the\n\"motif negative sampling\" (MNS) strategy described in Patil et al., \"Negative Sampling for Hyperlink Prediction in\nNetworks\", DOI: 10.1007/978-3-030-47436-2_46 (2020). MNS samples in such a way as to approximate the edge-density\ndistribution of hyperedges in `hg`. Note that MNS was not tested on directed hypergraphs in Patil et al., and it\nis possible that this algorithm does not produce the same or similar edge-density distributions to the hyperedge\nset in `hg`.\n\nIt is possible that any given hyperedge generated using motif negative sampling may be a duplicate or may not be a\nnegative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm\nwill attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still\npossible that less than `n` unique negative hyperedges will be produced.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.motif_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.motif_negative_sample","text":"motif_negative_sample(\n    hg::HGNNHypergraph{T, D},\n    n::Int,\n    rng::AbstractRNG;\n    max_trials::Int = 10\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nSample `n` negative hyperedges in an undirected hypergraph `hg` using a random number generator `rng` using the\n\"motif negative sampling\" (MNS) strategy described in Patil et al., \"Negative Sampling for Hyperlink Prediction in\nNetworks\", DOI: 10.1007/978-3-030-47436-2_46 (2020). MNS samples in such a way as to approximate the edge-density\ndistribution of hyperedges in `hg`. \n\nIt is possible that any given hyperedge generated using motif negatiive sampling may be a duplicate or may not be a\nnegative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm\nwill attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still\npossible that less than `n` unique negative hyperedges will be produced.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.negative_sample_hyperedge-Union{Tuple{S}, Tuple{H}, Tuple{H, Int64, Random.AbstractRNG, S}} where {H<:SimpleDirectedHypergraphs.AbstractDirectedHypergraph, S<:AbstractNegativeSamplingStrategy}","page":"Home","title":"HyperGraphNeuralNetworks.negative_sample_hyperedge","text":"negative_sample_hyperedge(\n    hg::H,\n    n::Int,\n    rng::AbstractRNG,\n    ::S;\n    max_trials::Int = 10\n) where {H <: AbstractDirectedHypergraph, S <: AbstractNegativeSamplingStrategy}\n\nSample `n` negative hyperedges in a directed hypergraph `hg` using a random number generator `rng` using the\nsampling strategy of type `S <: AbstractNegativeSamplingStrategy`. Currently, uniform sampling\n(`uniform_negative_sample`), sized negative sampling (`sized_negative_sample`), and motif negative sampling\n(`motif_negative_sample`) are implemented.\n\nIt is possible that any given hyperedge generated using this function may be a duplicate or may not be a\nnegative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm\nwill attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still\npossible that less than `n` unique negative hyperedges will be produced.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.negative_sample_hyperedge-Union{Tuple{S}, Tuple{H}, Tuple{H, Int64, Random.AbstractRNG, S}} where {H<:SimpleHypergraphs.AbstractSimpleHypergraph, S<:AbstractNegativeSamplingStrategy}","page":"Home","title":"HyperGraphNeuralNetworks.negative_sample_hyperedge","text":"negative_sample_hyperedge(\n    hg::H,\n    n::Int,\n    rng::AbstractRNG,\n    ::S;\n    max_trials::Int = 10\n) where {H <: AbstractSimpleHypergraph, S <: AbstractNegativeSamplingStrategy}\n\nSample `n` negative hyperedges in an undirected hypergraph `hg` using a random number generator `rng` using the\nsampling strategy of type `S <: AbstractNegativeSamplingStrategy`. Currently, uniform sampling\n(`uniform_negative_sample`), sized negative sampling (`sized_negative_sample`), motif negative sampling\n(`motif_negative_sample`), and clique negative sampling (`clique_negative_sample`) are implemented.\n\nIt is possible that any given hyperedge generated using this function may be a duplicate or may not be a\nnegative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm\nwill attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still\npossible that less than `n` unique negative hyperedges will be produced.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.normalized_laplacian_matrix-Tuple{H} where H<:SimpleDirectedHypergraphs.AbstractDirectedHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.normalized_laplacian_matrix","text":"normalized_laplacian_matrix(\n    h::H;\n    weighting_function::Function=sum,\n    combining_function::Function=_matrix_avg\n)\n\nReturns the normalized Laplacian for an undirected hypergraph `hg`.\n\nBecause of the ambiguity of defining hyperedge weight in the SimpleHypergraphs formalism, the user can\nspecify a `weighting_function` that, for each hyperedge, acts on the associated row of the matrix representation of\n`hg`; the default is `sum`. The user can also specify a `combining_function` for how the hyperedge tail and head\nweights should be combined to a single matrix; the default is to average the two matrices.\n\nLn = I - Qn,\nQn = Dv^(-1/2) A W De^(-1) A* Dv^(-1/2),\n\nwhere\n    Ln = normalized signed Laplacian (MxM)\n    I = identity matrix (MxM)\n    Qn = normalized Laplacian (MxM)\n    Dv = vertex degree matrix (MxM) <-- obtained by summing the tail and head degree matrices\n    De = hyperedge degree matrix (NxN) <-- obtained by summing the tail and head degree matrices\n    A = incidence matrix (MxN)\n    A* = conjugate transpose of A (NxM)\n    W = hyperedge weight matrix (NxN) <-- obtained by applying `combining_function` (default: averaging) to the\n        tail and head weight matrices\n\n    M = # vertices in `hg`\n    N = # hyperedges in `hg`\n\nReference:\n    Fiorini, S., Coniglio, S., Ciavotta, M., Del Bue, A., Let There be Direction in Hypergraph Neural Networks.\n    Transactions on Machine Learning Research, 2024.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.normalized_laplacian_matrix-Tuple{H} where H<:SimpleHypergraphs.AbstractSimpleHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.normalized_laplacian_matrix","text":"normalized_laplacian_matrix(hg::H; weighting_function::Function=sum) where {H <: AbstractSimpleHypergraph}\n\nReturns the normalized Laplacian for an undirected hypergraph `hg`.\n\nBecause of the ambiguity of defining hyperedge weight in the SimpleHypergraphs formalism, the user can\nspecify a `weighting_function` that, for each hyperedge, acts on the associated row of the matrix representation of\n`hg`; the default is `sum`.\n\nLn = I - Qn,\nQn = Dv^(-1/2) A W De^(-1) A* Dv^(-1/2),\n\nwhere\n    Ln = normalized signed Laplacian (MxM)\n    I = identity matrix (MxM)\n    Qn = normalized Laplacian (MxM)\n    Dv = vertex degree matrix (MxM)\n    De = hyperedge degree matrix (NxN)\n    A = incidence matrix (MxN)\n    A* = transpose of A (NxM)\n    W = hyperedge weight matrix (NxN)\n\n    M = # vertices in `hg`\n    N = # hyperedges in `hg`\n\nReference:\n    Fiorini, S., Coniglio, S., Ciavotta, M., Del Bue, A., Let There be Direction in Hypergraph Neural Networks.\n    Transactions on Machine Learning Research, 2024.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.print_all_features-Tuple{IO, Any, Any, Any}","page":"Home","title":"HyperGraphNeuralNetworks.print_all_features","text":"print_all_features(io::IO, vdata, hedata, hgdata)\nHelper function that reports the vertex, hyperedge, and hypergraph features of a hypergraph.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.random_dregular_hypergraph-Union{Tuple{H}, Tuple{Int64, Int64, Int64, Type{H}}} where H<:AbstractHGNNHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.random_dregular_hypergraph","text":"random_dregular_hypergraph(\n    nVertices::Int,\n    nEdges::Int,\n    d::Int,\n    HType::Type{H};\n    seed::Int = -1,\n    kws...\n) where {H <: AbstractHGNNHypergraph}\n\nrandom_dregular_hypergraph(\n    nVertices::Int,\n    nEdges::Int,\n    d::Int,\n    HType::Type{H};\n    seed::Int = -1,\n    no_self_loops::Bool = false,\n    kws...\n) where {H <: AbstractHGNNDiHypergraph}\n\nGenerates a *d*-regular hypergraph, where each node has degree *d*. See `SimpleHypergraphs.random_dregular_model`.\nThe user can optionally seed the random number generator with kwarg `seed`. The default value is -1; if the value\nis greater than or equal to 0, then `seed` will be used.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.random_kuniform_hypergraph-Union{Tuple{H}, Tuple{Int64, Int64, Int64, Type{H}}} where H<:AbstractHGNNHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.random_kuniform_hypergraph","text":"random_kuniform_hypergraph(\n    nVertices::Int,\n    nEdges::Int,\n    k::Int,\n    HType::Type{H};\n    seed::Int = -1,\n    kws...\n) where {H <: AbstractHGNNHypergraph}\n\nrandom_kuniform_hypergraph(\n    nVertices::Int,\n    nEdges::Int,\n    k::Int,\n    HType::Type{H};\n    seed::Int = -1,\n    no_self_loops::Bool = false,\n    kws...\n) where {H <: AbstractHGNNDiHypergraph}\n\nGenerates a *k*-uniform hypergraph, i.e. an hypergraph where each hyperedge has size *k*. For a directed hypergraph,\neach hyperedge has size *k = k_tail + k_head*, where *k_tail* and *k_head* are not necessarily equal. See \n`SimpleHypergraphs.random_kuniform_model`. The user can optionally seed the random number generator with kwarg\n`seed`. The default value is -1; if the value is greater than or equal to 0, then `seed` will be used.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.random_preferential_hypergraph-Union{Tuple{HO}, Tuple{HI}, Tuple{Int64, Real, Type{HO}}} where {HI<:SimpleHypergraphs.AbstractSimpleHypergraph, HO<:AbstractHGNNHypergraph}","page":"Home","title":"HyperGraphNeuralNetworks.random_preferential_hypergraph","text":"random_preferential_hypergraph(\n    nVertices::Int,\n    p::Real,\n    HType::Type{HO};\n    seed::Int = -1,\n    HTypeStart::Type{HI} = Hypergraph,\n    hg::HI = random_model(5,5, HI),\n    kws...\n) where {HI<:AbstractSimpleHypergraph, HO<:AbstractHGNNHypergraph}\n\nGenerate a hypergraph with a preferential attachment rule between nodes, as presented in\n*Avin, C., Lotker, Z., and Peleg, D. Random preferential attachment hyper-graphs. Computer Science 23 (2015).*\nSee `SimpleHypergraphs.random_preferential_model` for more details. The user can optionally seed the random number\ngenerator with kwarg `seed`. The default value is -1; if the value is greater than or equal to 0, then `seed` will\nbe used.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.random_split_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{<:Real}, Random.AbstractRNG}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.random_split_hyperedges","text":"random_split_hyperedges(\n    hg::HGNNHypergraph{T,D},\n    fracs::AbstractVector{<:Real},\n    rng::AbstractRNG\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nrandom_split_hyperedges(\n    hg::HGNNDiHypergraph{T,D},\n    fracs::AbstractVector{<:Real},\n    rng::AbstractRNG\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nRandomly partition a hypergraph `hg` by dividing the hyperedges (see `split_hyperedges`). Users provide the\n(relative) sizes of the partitions via `fracs`, a vector of real numbers. The sum of the fractions must equal 1,\nand all fractions must be between 0 and 1. Users must additionally provide a random number generator (`rng`).\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.random_split_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{<:Real}, Random.AbstractRNG}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.random_split_hypergraphs","text":"random_split_hypergraphs(\n    hg::HGNNHypergraph{T,D},\n    fracs::AbstractVector{<:Real},\n    rng::AbstractRNG\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nrandom_split_hypergraphs(\n    hg::HGNNDiHypergraph{T,D},\n    fracs::AbstractVector{<:Real},\n    rng::AbstractRNG\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nRandomly partition a hypergraph `hg` by dividing the (sub)-hypergraphs (see `split_hypergraphs`). Users provide the\n(relative) sizes of the partitions via `fracs`, a vector of real numbers. The sum of the fractions must equal 1,\nand all fractions must be between 0 and 1. Users must additionally provide a random number generator (`rng`).\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.random_split_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{<:Real}, Random.AbstractRNG}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.random_split_vertices","text":"random_split_vertices(\n    hg::HGNNHypergraph{T,D},\n    fracs::AbstractVector{<:Real},\n    rng::AbstractRNG\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nrandom_split_vertices(\n    hg::HGNNDiHypergraph{T,D},\n    fracs::AbstractVector{<:Real},\n    rng::AbstractRNG\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nRandomly partition a hypergraph `hg` by dividing the vertices (see `split_vertices`). Users provide the (relative)\nsizes of the partitions via `fracs`, a vector of real numbers. The sum of the fractions must equal 1, and all\nfractions must be between 0 and 1. Users must additionally provide a random number generator (`rng`).\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.remove_hyperedge-Tuple{HGNNHypergraph, Int64}","page":"Home","title":"HyperGraphNeuralNetworks.remove_hyperedge","text":"remove_hyperedge(hg::HGNNHypergraph, e::Int)\n\nRemoves the hyperedge `e` from a given undirected HGNNHypergraph `hg`. Note that this function creates a new\nHGNNHypergraph.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.remove_hyperedge-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.remove_hyperedge","text":"remove_hyperedge(hg::HGNNDiHypergraph, e::Int)\n\nRemoves the hyperedge e from a given undirected HGNNDiHypergraph hg. Note that this function creates a new HGNNDiHypergraph.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.remove_hyperedges-Tuple{HGNNHypergraph, AbstractVector{Int64}}","page":"Home","title":"HyperGraphNeuralNetworks.remove_hyperedges","text":"remove_hyperedges(hg::HGNNHypergraph, to_remove::AbstractVector{Int})\n\nRemoves a set of hyperedges (`to_remove`) from an undirected hypergraph `hg` by index\nNote that the index of v2he will be shifted down after the hyperedges removal.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.remove_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{Int64}}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.remove_hyperedges","text":"remove_hyperedges(hg::HGNNDiHypergraph, to_remove::AbstractVector{Int})\n\nRemoves a set of hyperedges (`to_remove`) from a directed hypergraph `hg` by index\nNote that the index of both v2he_tail and v2he_head will be shifted down after \nthe vertices removal.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.remove_multi_hyperedges-Tuple{HGNNDiHypergraph}","page":"Home","title":"HyperGraphNeuralNetworks.remove_multi_hyperedges","text":"remove_multi_hyperedges(hg::HGNNHypergraph)\n\nRemove duplicate hyperedges, i.e., hyperedges ei = (ti, hi), ej = (tj, hj), where t represents a hyperedge tail, h\nrepresents a hyperedge head, and ti = tj and hi = hj, from a directed hypergraph `hg`.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.remove_multi_hyperedges-Tuple{HGNNHypergraph}","page":"Home","title":"HyperGraphNeuralNetworks.remove_multi_hyperedges","text":"remove_multi_hyperedges(hg::HGNNHypergraph)\n\nRemove duplicate hyperedges (hyperedges containing identical vertices) from an undirected hypergraph `hg`.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.remove_self_loops-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.remove_self_loops","text":"remove_self_loops(hg::HGNNDiHypergraph{T, D}) where {T<:Real, D<:AbstractDict{Int,T}}\n\nRemove self-loops (hyperedges where the tail and head both contain only a single, shared vertex `v`) from a\ndirected hypergraph `hg`.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.remove_self_loops-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.remove_self_loops","text":"remove_self_loops(hg::HGNNHypergraph{T, D}) where {T<:Real, D<:AbstractDict{Int,T}}\n\nRemove self-loops (hyperedges containing only one vertex) from an undirected hypergraph `hg`.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.remove_vertex-Tuple{HGNNHypergraph, Int64}","page":"Home","title":"HyperGraphNeuralNetworks.remove_vertex","text":"remove_vertex(hg::HGNNHypergraph, v::Int)\n\nRemoves the vertex `v` from a given `HGNNHypergraph` `hg`. Note that this creates a new HGNNHypergraph, as\nHGNNHypergraph objects are immutable.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.remove_vertex-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.remove_vertex","text":"remove_vertex(hg::HGNNDiHypergraph, v::Int)\n\nRemoves the vertex `v` from a given `HGNNDiHypergraph` `hg`. Note that this creates a new HGNNDiHypergraph, as\nHGNNDiHypergraph objects are immutable.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.remove_vertices-Tuple{HGNNHypergraph, AbstractVector{Int64}}","page":"Home","title":"HyperGraphNeuralNetworks.remove_vertices","text":"remove_vertices(hg::HGNNHypergraph, to_remove::AbstractVector{Int})\n\nRemoves a set of vertices (`to_remove`) from an undirected hypergraph `hg` by index\nNote that the index of he2v will be shifted down after the vertices removal.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.remove_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{Int64}}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.remove_vertices","text":"remove_vertices(hg::HGNNDiHypergraph, to_remove::AbstractVector{Int})\n\nRemoves a set of vertices (`to_remove`) from a directed hypergraph `hg` by index\nNote that the index of both he2v_tail and he2v_head will be shifted down after \nthe vertices removal.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.sized_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.sized_negative_sample","text":"sized_negative_sample(\n    hg::HGNNDiHypergraph{T, D},\n    n::Int,\n    rng::AbstractRNG;\n    max_trials::Int = 10\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nSample `n` negative hyperedges in a directed hypergraph `hg` using a random number generator `rng` in such a way\nas to ensure that the size distribution of negative hyperedges generated approximately matches that of hyperedges\nin `hg`. Specifically, this algorithm samples hypergraphs with total size `|e| = |e_tail| + |e_head|` based on the\ntotal size distribution in the hyperedge set of `hg` and further samples the tail sizes `|e_tail|` based on the\ntail size distribution in the hyperedge set of `hg`. \n\nIt is possible that any given hyperedge generated using sized sampling may be a duplicate or may not be a\nnegative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm\nwill attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still\npossible that less than `n` unique negative hyperedges will be produced.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.sized_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.sized_negative_sample","text":"sized_negative_sample(\n    hg::HGNNHypergraph{T, D},\n    n::Int,\n    rng::AbstractRNG;\n    max_trials::Int = 10\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nSample `n` negative hyperedges in an undirected hypergraph `hg` using a random number generator `rng` in such a way\nas to ensure that the size distribution of negative hyperedges generated approximately matches that of hyperedges\nin `hg`.\n\nIt is possible that any given hyperedge generated using sized sampling may be a duplicate or may not be a\nnegative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm\nwill attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still\npossible that less than `n` unique negative hyperedges will be produced.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.split_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{BitVector}}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.split_hyperedges","text":"split_hyperedges(\n    hg::HGNNDiHypergraph{T,D},\n    masks::AbstractVector{BitVector}\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nsplit_hyperedges(\n    hg::HGNNDiHypergraph{T, D},\n    train_mask::BitVector,\n    test_mask::BitVector;\n    val_mask::Union{BitVector, Nothing} = nothing,\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nsplit_hyperedges(\n    hg::HGNNDiHypergraph{T,D},\n    index_groups::AbstractVector{V}\n) where {T <: Real, D <: AbstractDict{Int, T}, V <: AbstractVector{Int}}\n\nsplit_hyperedges(\n    hg::HGNNDiHypergraph{T,D},\n    train_inds::AbstractVector{Int},\n    test_inds::AbstractVector{Int};\n    val_inds::Union{AbstractVector{Int}, Nothing} = nothing\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nSplit a single `HGNNDiHypergraph` into an arbitrary number of `HGNNDiHypergraph`s by partitioning hyperedges. This\nwill also partition vertices and hypergraphs. If a vertex is not incident on any hyperedge in a particular\npartition, then that vertex and its associated features will not be present in the resulting `HGNNDiHypergraph`.\nSimilarly, if no relevant vertex in the partition belongs to a particular sub-hypergraph (based on\n`hypergraph_id`s), then that hypergraph and its associated features will not be present in the resulting\n`HGNNDiHypergraph`.\n\nUsers can provide partitions as `BitVector` masks (length `E`, where `E` is the number of hyperedges) or vectors of\nindices (which will be converted into masks). To facilitate train-val-test splits, users can specify which\nmask/indices correspond to the train set, test set, and (optionally) validation set. In these cases, the output of\n`split_vertices` will be a `NamedTuple` with keys \"train\", \"test\", and (optionally) \"val\" and values of\n`HGNNDiHypergraph`s; otherwise, the output is a vector of `HGNNDiHypergraph`s.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.split_hyperedges-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{BitVector}}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.split_hyperedges","text":"split_hyperedges(\n    hg::HGNNHypergraph{T,D},\n    masks::AbstractVector{BitVector}\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nsplit_hyperedges(\n    hg::HGNNHypergraph{T, D},\n    train_mask::BitVector,\n    test_mask::BitVector;\n    val_mask::Union{BitVector, Nothing} = nothing,\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nsplit_hyperedges(\n    hg::HGNNHypergraph{T,D},\n    index_groups::AbstractVector{V}\n) where {T <: Real, D <: AbstractDict{Int, T}, V <: AbstractVector{Int}}\n\nsplit_hyperedges(\n    hg::HGNNHypergraph{T,D},\n    train_inds::AbstractVector{Int},\n    test_inds::AbstractVector{Int};\n    val_inds::Union{AbstractVector{Int}, Nothing} = nothing\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nSplit a single `HGNNHypergraph` into an arbitrary number of `HGNNHypergraph`s by partitioning hyperedges. This will\nalso partition vertices and hypergraphs. If a vertex is not incident on any hyperedge in a particular partition,\nthen that vertex and its associated features will not be present in the resulting `HGNNHypergraph`. If none of the\nrelevant vertices in a partition belong to a particular sub-hypergraph (based on `hypergraph_id`s), then that\nhypergraph and its associated features will not be present in the resulting `HGNNHypergraph`.\n\nUsers can provide partitions as `BitVector` masks (length `E`, where `E` is the number of hyperedges) or vectors\nof indices (which will be converted into masks). To facilitate train-val-test splits, users can specify which\nmask/indices correspond to the train set, test set, and (optionally) validation set. In these cases, the output\nof `split_vertices` will be a `NamedTuple` with keys \"train\", \"test\", and (optionally) \"val\" and values of\n`HGNNHypergraph`s; otherwise, the output is a vector of `HGNNHypergraph`s.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.split_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{BitVector}}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.split_hypergraphs","text":"split_hypergraphs(\n    hg::HGNNDiHypergraph{T,D},\n    masks::AbstractVector{BitVector}\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nsplit_hypergraphs(\n    hg::HGNNDiHypergraph{T,D},\n    train_mask::BitVector,\n    test_mask::BitVector;\n    val_mask::Union{BitVector, Nothing} = nothing,\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nsplit_hypergraphs(\n    hg::HGNNDiHypergraph{T,D},\n    index_groups::AbstractVector{V}\n) where {T <: Real, D <: AbstractDict{Int, T}, V <: AbstractVector{Int}}\n\nsplit_hypergraphs(\n    hg::HGNNDiHypergraph{T,D},\n    train_inds::AbstractVector{Int},\n    test_inds::AbstractVector{Int};\n    val_inds::Union{AbstractVector{Int}, Nothing} = nothing\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nSplit a single `HGNNDiHypergraph` into an arbitrary number of `HGNNDiHypergraph`s by partitioning hypergraphs (from\nvertex `hypergraph_id`s). This will also partition vertices and hyperedges. If a vertex's `hypergraph_id` is not\nincluded in the partition, then that vertex and its associated features will not be present in the resulting\n`HGNNDiHypergraph`. If none of the relevant vertices in a partition are incident on a particular hyperedge, then\nthat hyperedge and its associated features will not be present in the resulting `HGNNDiHypergraph`.\n\nUsers can provide partitions as `BitVector` masks (length `G`, where `G` is the number of hypergraphs in this\n`HGNNDiHypergraph`) or vectors of indices (which will be converted into masks). To facilitate train-val-test\nsplits, users can specify which mask/indices correspond to the train set, test set, and (optionally) validation\nset. In these cases, the output of `split_vertices` will be a `NamedTuple` with keys \"train\", \"test\", and\n(optionally) \"val\" and values of `HGNNDiHypergraph`s; otherwise, the output is a vector of `HGNNDiHypergraph`s.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.split_hypergraphs-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{BitVector}}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.split_hypergraphs","text":"split_hypergraphs(\n    hg::HGNNHypergraph{T,D},\n    masks::AbstractVector{BitVector}\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nsplit_hypergraphs(\n    hg::HGNNHypergraph{T,D},\n    train_mask::BitVector,\n    test_mask::BitVector;\n    val_mask::Union{BitVector, Nothing} = nothing,\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nsplit_hypergraphs(\n    hg::HGNNHypergraph{T,D},\n    index_groups::AbstractVector{V}\n) where {T <: Real, D <: AbstractDict{Int, T}, V <: AbstractVector{Int}}\n\nsplit_hypergraphs(\n    hg::HGNNHypergraph{T,D},\n    train_inds::AbstractVector{Int},\n    test_inds::AbstractVector{Int};\n    val_inds::Union{AbstractVector{Int}, Nothing} = nothing\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nSplit a single `HGNNHypergraph` into an arbitrary number of `HGNNHypergraph`s by partitioning hypergraphs (from\nvertex `hypergraph_id`s). This will also partition vertices and hyperedges. If a vertex's `hypergraph_id` is not\nincluded in the partition, then that vertex and its associated features will not be present in the resulting\n`HGNNHypergraph`. If none of the relevant vertices in a partition are incident on a particular hyperedge, then that\nhyperedge and its associated features will not be present in the resulting `HGNNHypergraph`.\n\nUsers can provide partitions as `BitVector` masks (length `G`, where `G` is the number of hypergraphs in this\n`HGNNHypergraph`) or vectors of indices (which will be converted into masks). To facilitate train-val-test\nsplits, users can specify which mask/indices correspond to the train set, test set, and (optionally) validation\nset. In these cases, the output of `split_vertices` will be a `NamedTuple` with keys \"train\", \"test\", and\n(optionally) \"val\" and values of `HGNNHypergraph`s; otherwise, the output is a vector of `HGNNHypergraph`s.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.split_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, AbstractVector{BitVector}}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.split_vertices","text":"split_vertices(\n    hg::HGNNDiHypergraph{T,D},\n    masks::AbstractVector{BitVector}\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nsplit_vertices(\n    hg::HGNNDiHypergraph{T,D},\n    train_mask::BitVector,\n    test_mask::BitVector;\n    val_mask::Union{BitVector, Nothing} = nothing,\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nsplit_vertices(\n    hg::HGNNDiHypergraph{T,D},\n    index_groups::AbstractVector{V}\n) where {T <: Real, D <: AbstractDict{Int, T}, V <: AbstractVector{Int}}\n\nsplit_vertices(\n    hg::HGNNDiHypergraph{T,D},\n    train_inds::AbstractVector{Int},\n    test_inds::AbstractVector{Int};\n    val_inds::Union{AbstractVector{Int}, Nothing} = nothing\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nSplit a single `HGNNDiHypergraph` into an arbitrary number of `HGNNDiHypergraph`s by partitioning vertices. This\nwill also partition hyperedges and hypergraphs. If no vertex in a particular partition is incident on a hyperedge,\nthen that hyperedge and its associated features will not be present in the resulting `HGNNDiHypergraph`. Similarly,\nif no vertex in the partition belongs to a particular sub-hypergraph (based on `hypergraph_id`s), then that\nhypergraph and its associated features will not be present in the resulting `HGNNDiHypergraph`.\n\nUsers can provide partitions as `BitVector` masks (length `V`, where `V` is the number of vertices) or vectors of\nindices (which will be converted into masks). To facilitate train-val-test splits, users can specify which\nmask/indices correspond to the train set, test set, and (optionally) validation set. In these cases, the output of\n`split_vertices` will be a `NamedTuple` with keys \"train\", \"test\", and (optionally) \"val\" and values of\n`HGNNDiHypergraph`s; otherwise, the output is a vector of `HGNNDiHypergraph`s.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.split_vertices-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, AbstractVector{BitVector}}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.split_vertices","text":"split_vertices(\n    hg::HGNNHypergraph{T,D},\n    masks::AbstractVector{BitVector}\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nsplit_vertices(\n    hg::HGNNHypergraph{T,D},\n    train_mask::BitVector,\n    test_mask::BitVector;\n    val_mask::Union{BitVector, Nothing} = nothing,\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nsplit_vertices(\n    hg::HGNNHypergraph{T,D},\n    index_groups::AbstractVector{V}\n) where {T <: Real, D <: AbstractDict{Int, T}, V <: AbstractVector{Int}}\n\nsplit_vertices(\n    hg::HGNNHypergraph{T,D},\n    train_inds::AbstractVector{Int},\n    test_inds::AbstractVector{Int};\n    val_inds::Union{AbstractVector{Int}, Nothing} = nothing\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nSplit a single `HGNNHypergraph` into an arbitrary number of `HGNNHypergraph`s by partitioning vertices. This will\nalso partition hyperedges and hypergraphs. If no vertex in a particular partition is incident on a hyperedge, then\nthat hyperedge and its associated features will not be present in the resulting `HGNNHypergraph`. Similarly, if no\nvertex in the partition belongs to a particular sub-hypergraph (based on `hypergraph_id`s), then that hypergraph\nand its associated features will not be present in the resulting `HGNNHypergraph`.\n\nUsers can provide partitions as `BitVector` masks (length `V`, where `V` is the number of vertices) or vectors of\nindices (which will be converted into masks). To facilitate train-val-test splits, users can specify which\nmask/indices correspond to the train set, test set, and (optionally) validation set. In these cases, the output\nof `split_vertices` will be a `NamedTuple` with keys \"train\", \"test\", and (optionally) \"val\" and values of\n`HGNNHypergraph`s; otherwise, the output is a vector of `HGNNHypergraph`s.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.to_undirected-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.to_undirected","text":"to_undirected(hg::HGNNDiHypergraph{T,D}) where {T <: Real, D <: AbstractDict{Int, T}}\n\nConverts a directed hypergraph into an undirected hypergraph.\nTail and head hyperedges are combined; that is, for all hyperedges he_orig in\nthe directed hypergraph h, all vertices in the head or tail are added to a\ncorresponding undirected hyperedge he_new in the undirected hypergraph h'.\n\nVertex, hyperedge, and hypergraph features, as well as the hypergraph IDs, are undisturbed.\n\nBecause vertex-hyperedge weights are restricted to real numbers, we cannot\ncombine the weights, so we simply set the values to 1.0 if a given vertex\nis in a given hyperedge\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.uniform_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNDiHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.uniform_negative_sample","text":"uniform_negative_sample(\n    hg::HGNNDiHypergraph{T, D},\n    n::Int,\n    rng::AbstractRNG;\n    max_trials::Int = 10\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nSample `n` negative hyperedges in a directed hypergraph `hg` using a random number generator `rng`\nand a uniform sampling strategy.\n\nIt is possible that any given hyperedge generated using uniform sampling may be a duplicate or may not be a\nnegative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm\nwill attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still\npossible that less than `n` unique negative hyperedges will be produced.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.uniform_negative_sample-Union{Tuple{D}, Tuple{T}, Tuple{HGNNHypergraph{T, D}, Int64, Random.AbstractRNG}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"HyperGraphNeuralNetworks.uniform_negative_sample","text":"uniform_negative_sample(\n    hg::HGNNHypergraph{T, D},\n    n::Int,\n    rng::AbstractRNG;\n    max_trials::Int = 10\n) where {T <: Real, D <: AbstractDict{Int, T}}\n\nSample `n` negative hyperedges in an undirected hypergraph `hg` using a random number generator `rng`\nand a uniform sampling strategy.\n\nIt is possible that any given hyperedge generated using uniform sampling may be a duplicate or may not be a\nnegative hyperedge (i.e., it may exist in the hyperedge set of `hg`). To minimize this possibility, the algorithm\nwill attempt to generate negative hyperedges `max_trials` number of times (default: 10). However, it is still\npossible that less than `n` unique negative hyperedges will be produced.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.vertex_degree_matrix-Tuple{H} where H<:SimpleHypergraphs.AbstractSimpleHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.vertex_degree_matrix","text":"vertex_degree_matrix(hg::H) where {H <: AbstractSimpleHypergraph}\nvertex_degree_matrix(hg::H) where {H <: AbstractDirectedHypergraph}\n\nA `VxV` matrix (where `V` is the number of vertices in `hg`) where the diagonal element `(i,i)` is the degree of\nvertex `i` and all other elements are 0. For directed hypergraphs, two degree matrices are provided: one with\ndiagonal elements equal to the number of hyperedges in which a given vertex is in the tail and the other with\ndiagonal elements equal to the number of hyperedges in which a given vertex is in the head.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.vertex_weight_matrix-Tuple{H} where H<:SimpleDirectedHypergraphs.AbstractDirectedHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.vertex_weight_matrix","text":"vertex_weight_matrix(hg::H; weighting_function::Function=sum) where {H <: AbstractDirectedHypergraph}\n\nReturn two NxN diagonal weight matrices for the directed hypergraph `hg`, where N is the number of vertices in\n`hg`. One matrix is based on the hyperedge tails that each vertex is included in; the other is based on the\nhyperedge heads that each vertex is included in. Because SimpleHypergraphs hypergraphs can have different weights\nfor each vertex-hyperedge pair, the weight of a vertex is ambiguous. The user can specify a `weighting_function`\n(default is `sum`) that operates on each row of the hypergraph tail/head weighted incidence matrix.\n\n\n\n\n\n","category":"method"},{"location":"#HyperGraphNeuralNetworks.vertex_weight_matrix-Tuple{H} where H<:SimpleHypergraphs.AbstractSimpleHypergraph","page":"Home","title":"HyperGraphNeuralNetworks.vertex_weight_matrix","text":"vertex_weight_matrix(hg::H; weighting_function::Function=sum) where {H <: AbstractSimpleHypergraph}\n\nReturn an NxN diagonal weight matrix for the undirected hypergraph `hg`, where N is the number of vertices in `hg`.\nBecause SimpleHypergraphs hypergraphs can have different weights for each vertex-hyperedge pair, the weight of a\nvertex is ambiguous. The user can specify a `weighting_function` (default is `sum`) that operates on each row of\nthe hypergraph weighted incidence matrix.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleHypergraphs.add_hyperedge!-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"SimpleHypergraphs.add_hyperedge!","text":"add_hyperedge!(::HGNNDiHypergraph{T, D}; ::D = D()) where {T <: Real, D <: AbstractDict{Int,T}}\n\nThis function is not implemented for HGNNDiHypergraph.\n    \nThe basic hypergraph structure of HGNNDiHypergraph (i.e., the number of vertices, the hyperedges, and the hypergraph\nIDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore\nobjects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.\n\nTo create a new HGNNDiHypergraph object with an additional hyperedge, use `add_hyperedge`.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleHypergraphs.add_hyperedge!-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"SimpleHypergraphs.add_hyperedge!","text":"add_hyperedge!(::HGNNHypergraph{T, D}; ::D = D()) where {T <: Real, D <: AbstractDict{Int,T}}\n\nThis function is not implemented for HGNNHypergraph.\n    \nThe basic hypergraph structure of HGNNHypergraph (i.e., the number of vertices, the hyperedges, and the hypergraph\nIDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore\nobjects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.\n\nTo create a new HGNNHypergraph object with an additional hyperedge, use `add_hyperedge`.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleHypergraphs.add_vertex!-Union{Tuple{HGNNDiHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"SimpleHypergraphs.add_vertex!","text":"(::HGNNDiHypergraph{T, D}; ::D = D()) where {T <: Real, D <: AbstractDict{Int,T}}\n\nThis function is not implemented for HGNNDiHypergraph.\n    \nThe basic hypergraph structure of HGNNDiHypergraph (i.e., the number of vertices, the hyperedges, and the\nhypergraph IDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore\nobjects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.\n\nTo create a new HGNNDiHypergraph object with an additional vertex, use `add_vertex`.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleHypergraphs.add_vertex!-Union{Tuple{HGNNHypergraph{T, D}}, Tuple{D}, Tuple{T}} where {T<:Real, D<:AbstractDict{Int64, T}}","page":"Home","title":"SimpleHypergraphs.add_vertex!","text":"add_vertex!(::HGNNHypergraph{T, D}; ::D = D()) where {T <: Real, D <: AbstractDict{Int,T}}\n\nThis function is not implemented for HGNNHypergraph.\n    \nThe basic hypergraph structure of HGNNHypergraph (i.e., the number of vertices, the hyperedges, and the hypergraph\nIDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore\nobjects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.\n\nTo create a new HGNNHypergraph object with an additional vertex, use `add_vertex`.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleHypergraphs.remove_hyperedge!-Tuple{HGNNDiHypergraph, Int64}","page":"Home","title":"SimpleHypergraphs.remove_hyperedge!","text":"remove_hyperedge!(::HGNNHypergraph, ::Int)\n\nThis function is not implemented for HGNNHypergraph.\n    \nThe basic hypergraph structure of HGNNHypergraph (i.e., the number of vertices, the hyperedges, and the hypergraph\nIDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore\nobjects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.\n\nTo create a new HGNNHypergraph object with a hyperedge removed, use `remove_hyperedge`.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleHypergraphs.remove_hyperedge!-Tuple{HGNNHypergraph, Int64}","page":"Home","title":"SimpleHypergraphs.remove_hyperedge!","text":"remove_hyperedge!(::HGNNHypergraph, ::Int)\n\nThis function is not implemented for HGNNHypergraph.\n    \nThe basic hypergraph structure of HGNNHypergraph (i.e., the number of vertices, the hyperedges, and the hypergraph\nIDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore\nobjects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.\n\nTo create a new HGNNHypergraph object with a hyperedge removed, use `remove_hyperedge`.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleHypergraphs.remove_vertex!-Tuple{HGNNDiHypergraph, Int64}","page":"Home","title":"SimpleHypergraphs.remove_vertex!","text":"remove_vertex!(::HGNNDiHypergraph, ::Int)\n\nThis function is not implemented for HGNNDiHypergraph.\n    \nThe basic hypergraph structure of HGNNDiHypergraph (i.e., the number of vertices, the hyperedges, and the hypergraph\nIDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore\nobjects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.\n\nTo create a new HGNNDiHypergraph object with a vertex removed, use `remove_vertex`.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleHypergraphs.remove_vertex!-Tuple{HGNNHypergraph, Int64}","page":"Home","title":"SimpleHypergraphs.remove_vertex!","text":"remove_vertex!(::HGNNHypergraph, ::Int)\n\nThis function is not implemented for HGNNHypergraph.\n    \nThe basic hypergraph structure of HGNNHypergraph (i.e., the number of vertices, the hyperedges, and the hypergraph\nIDs) are not mutable. Users can change the features in the `vdata`, `hedata`, and `hgdata` DataStore\nobjects, but the number of vertices, number of hyperedges, and number of hypergraphs cannot change.\n\nTo create a new HGNNHypergraph object with a vertex removed, use `remove_vertex`.\n\n\n\n\n\n","category":"method"}]
}
